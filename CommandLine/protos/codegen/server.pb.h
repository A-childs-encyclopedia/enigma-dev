// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef PROTOBUF_INCLUDED_server_2eproto
#define PROTOBUF_INCLUDED_server_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "game.pb.h"
#include "Settings.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_server_2eproto 

namespace protobuf_server_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_server_2eproto
namespace buffers {
class CompileReply;
class CompileReplyDefaultTypeInternal;
extern CompileReplyDefaultTypeInternal _CompileReply_default_instance_;
class CompileRequest;
class CompileRequestDefaultTypeInternal;
extern CompileRequestDefaultTypeInternal _CompileRequest_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class LogMessage;
class LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class ProgressMessage;
class ProgressMessageDefaultTypeInternal;
extern ProgressMessageDefaultTypeInternal _ProgressMessage_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class SetCurrentConfigRequest;
class SetCurrentConfigRequestDefaultTypeInternal;
extern SetCurrentConfigRequestDefaultTypeInternal _SetCurrentConfigRequest_default_instance_;
class SetDefinitionsRequest;
class SetDefinitionsRequestDefaultTypeInternal;
extern SetDefinitionsRequestDefaultTypeInternal _SetDefinitionsRequest_default_instance_;
class SyntaxCheckRequest;
class SyntaxCheckRequestDefaultTypeInternal;
extern SyntaxCheckRequestDefaultTypeInternal _SyntaxCheckRequest_default_instance_;
class SyntaxError;
class SyntaxErrorDefaultTypeInternal;
extern SyntaxErrorDefaultTypeInternal _SyntaxError_default_instance_;
class SystemInfo;
class SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
class SystemType;
class SystemTypeDefaultTypeInternal;
extern SystemTypeDefaultTypeInternal _SystemType_default_instance_;
}  // namespace buffers
namespace google {
namespace protobuf {
template<> ::buffers::CompileReply* Arena::CreateMaybeMessage<::buffers::CompileReply>(Arena*);
template<> ::buffers::CompileRequest* Arena::CreateMaybeMessage<::buffers::CompileRequest>(Arena*);
template<> ::buffers::Empty* Arena::CreateMaybeMessage<::buffers::Empty>(Arena*);
template<> ::buffers::LogMessage* Arena::CreateMaybeMessage<::buffers::LogMessage>(Arena*);
template<> ::buffers::ProgressMessage* Arena::CreateMaybeMessage<::buffers::ProgressMessage>(Arena*);
template<> ::buffers::Resource* Arena::CreateMaybeMessage<::buffers::Resource>(Arena*);
template<> ::buffers::SetCurrentConfigRequest* Arena::CreateMaybeMessage<::buffers::SetCurrentConfigRequest>(Arena*);
template<> ::buffers::SetDefinitionsRequest* Arena::CreateMaybeMessage<::buffers::SetDefinitionsRequest>(Arena*);
template<> ::buffers::SyntaxCheckRequest* Arena::CreateMaybeMessage<::buffers::SyntaxCheckRequest>(Arena*);
template<> ::buffers::SyntaxError* Arena::CreateMaybeMessage<::buffers::SyntaxError>(Arena*);
template<> ::buffers::SystemInfo* Arena::CreateMaybeMessage<::buffers::SystemInfo>(Arena*);
template<> ::buffers::SystemType* Arena::CreateMaybeMessage<::buffers::SystemType>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace buffers {

enum CompileRequest_CompileMode {
  CompileRequest_CompileMode_UNKNOWN = 0,
  CompileRequest_CompileMode_RUN = 1,
  CompileRequest_CompileMode_DEBUG = 2,
  CompileRequest_CompileMode_DESIGN = 3,
  CompileRequest_CompileMode_COMPILE = 4,
  CompileRequest_CompileMode_REBUILD = 5
};
bool CompileRequest_CompileMode_IsValid(int value);
const CompileRequest_CompileMode CompileRequest_CompileMode_CompileMode_MIN = CompileRequest_CompileMode_UNKNOWN;
const CompileRequest_CompileMode CompileRequest_CompileMode_CompileMode_MAX = CompileRequest_CompileMode_REBUILD;
const int CompileRequest_CompileMode_CompileMode_ARRAYSIZE = CompileRequest_CompileMode_CompileMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompileRequest_CompileMode_descriptor();
inline const ::std::string& CompileRequest_CompileMode_Name(CompileRequest_CompileMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompileRequest_CompileMode_descriptor(), value);
}
inline bool CompileRequest_CompileMode_Parse(
    const ::std::string& name, CompileRequest_CompileMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompileRequest_CompileMode>(
    CompileRequest_CompileMode_descriptor(), name, value);
}
enum LogMessage_Severity {
  LogMessage_Severity_UNKNOWN = 0,
  LogMessage_Severity_FINE = 1,
  LogMessage_Severity_INFO = 2,
  LogMessage_Severity_WARNING = 3,
  LogMessage_Severity_ERROR = 4
};
bool LogMessage_Severity_IsValid(int value);
const LogMessage_Severity LogMessage_Severity_Severity_MIN = LogMessage_Severity_UNKNOWN;
const LogMessage_Severity LogMessage_Severity_Severity_MAX = LogMessage_Severity_ERROR;
const int LogMessage_Severity_Severity_ARRAYSIZE = LogMessage_Severity_Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogMessage_Severity_descriptor();
inline const ::std::string& LogMessage_Severity_Name(LogMessage_Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogMessage_Severity_descriptor(), value);
}
inline bool LogMessage_Severity_Parse(
    const ::std::string& name, LogMessage_Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogMessage_Severity>(
    LogMessage_Severity_descriptor(), name, value);
}
// ===================================================================

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:buffers.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(Resource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Resource* other);
  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const final {
    return CreateMaybeMessage<Resource>(NULL);
  }

  Resource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string parameters = 9;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 9;
  const ::std::string& parameters(int index) const;
  ::std::string* mutable_parameters(int index);
  void set_parameters(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_parameters(int index, ::std::string&& value);
  #endif
  void set_parameters(int index, const char* value);
  void set_parameters(int index, const char* value, size_t size);
  ::std::string* add_parameters();
  void add_parameters(const ::std::string& value);
  #if LANG_CXX11
  void add_parameters(::std::string&& value);
  #endif
  void add_parameters(const char* value);
  void add_parameters(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& parameters() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_parameters();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 arg_count_min = 3;
  bool has_arg_count_min() const;
  void clear_arg_count_min();
  static const int kArgCountMinFieldNumber = 3;
  ::google::protobuf::int32 arg_count_min() const;
  void set_arg_count_min(::google::protobuf::int32 value);

  // optional int32 arg_count_max = 4;
  bool has_arg_count_max() const;
  void clear_arg_count_max();
  static const int kArgCountMaxFieldNumber = 4;
  ::google::protobuf::int32 arg_count_max() const;
  void set_arg_count_max(::google::protobuf::int32 value);

  // optional int32 overload_count = 5;
  bool has_overload_count() const;
  void clear_overload_count();
  static const int kOverloadCountFieldNumber = 5;
  ::google::protobuf::int32 overload_count() const;
  void set_overload_count(::google::protobuf::int32 value);

  // optional bool is_function = 2;
  bool has_is_function() const;
  void clear_is_function();
  static const int kIsFunctionFieldNumber = 2;
  bool is_function() const;
  void set_is_function(bool value);

  // optional bool is_end = 8;
  bool has_is_end() const;
  void clear_is_end();
  static const int kIsEndFieldNumber = 8;
  bool is_end() const;
  void set_is_end(bool value);

  // optional int32 is_type_name = 6;
  bool has_is_type_name() const;
  void clear_is_type_name();
  static const int kIsTypeNameFieldNumber = 6;
  ::google::protobuf::int32 is_type_name() const;
  void set_is_type_name(::google::protobuf::int32 value);

  // optional int32 is_global = 7;
  bool has_is_global() const;
  void clear_is_global();
  static const int kIsGlobalFieldNumber = 7;
  ::google::protobuf::int32 is_global() const;
  void set_is_global(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.Resource)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_is_function();
  void clear_has_is_function();
  void set_has_arg_count_min();
  void clear_has_arg_count_min();
  void set_has_arg_count_max();
  void clear_has_arg_count_max();
  void set_has_overload_count();
  void clear_has_overload_count();
  void set_has_is_type_name();
  void clear_has_is_type_name();
  void set_has_is_global();
  void clear_has_is_global();
  void set_has_is_end();
  void clear_has_is_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> parameters_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 arg_count_min_;
  ::google::protobuf::int32 arg_count_max_;
  ::google::protobuf::int32 overload_count_;
  bool is_function_;
  bool is_end_;
  ::google::protobuf::int32 is_type_name_;
  ::google::protobuf::int32 is_global_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.CompileRequest) */ {
 public:
  CompileRequest();
  virtual ~CompileRequest();

  CompileRequest(const CompileRequest& from);

  inline CompileRequest& operator=(const CompileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompileRequest(CompileRequest&& from) noexcept
    : CompileRequest() {
    *this = ::std::move(from);
  }

  inline CompileRequest& operator=(CompileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompileRequest* internal_default_instance() {
    return reinterpret_cast<const CompileRequest*>(
               &_CompileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CompileRequest* other);
  friend void swap(CompileRequest& a, CompileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompileRequest* New() const final {
    return CreateMaybeMessage<CompileRequest>(NULL);
  }

  CompileRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompileRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompileRequest& from);
  void MergeFrom(const CompileRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompileRequest_CompileMode CompileMode;
  static const CompileMode UNKNOWN =
    CompileRequest_CompileMode_UNKNOWN;
  static const CompileMode RUN =
    CompileRequest_CompileMode_RUN;
  static const CompileMode DEBUG =
    CompileRequest_CompileMode_DEBUG;
  static const CompileMode DESIGN =
    CompileRequest_CompileMode_DESIGN;
  static const CompileMode COMPILE =
    CompileRequest_CompileMode_COMPILE;
  static const CompileMode REBUILD =
    CompileRequest_CompileMode_REBUILD;
  static inline bool CompileMode_IsValid(int value) {
    return CompileRequest_CompileMode_IsValid(value);
  }
  static const CompileMode CompileMode_MIN =
    CompileRequest_CompileMode_CompileMode_MIN;
  static const CompileMode CompileMode_MAX =
    CompileRequest_CompileMode_CompileMode_MAX;
  static const int CompileMode_ARRAYSIZE =
    CompileRequest_CompileMode_CompileMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompileMode_descriptor() {
    return CompileRequest_CompileMode_descriptor();
  }
  static inline const ::std::string& CompileMode_Name(CompileMode value) {
    return CompileRequest_CompileMode_Name(value);
  }
  static inline bool CompileMode_Parse(const ::std::string& name,
      CompileMode* value) {
    return CompileRequest_CompileMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .buffers.Game game = 1;
  bool has_game() const;
  void clear_game();
  static const int kGameFieldNumber = 1;
  private:
  const ::buffers::Game& _internal_game() const;
  public:
  const ::buffers::Game& game() const;
  ::buffers::Game* release_game();
  ::buffers::Game* mutable_game();
  void set_allocated_game(::buffers::Game* game);

  // optional .buffers.CompileRequest.CompileMode mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::buffers::CompileRequest_CompileMode mode() const;
  void set_mode(::buffers::CompileRequest_CompileMode value);

  // @@protoc_insertion_point(class_scope:buffers.CompileRequest)
 private:
  void set_has_game();
  void clear_has_game();
  void set_has_name();
  void clear_has_name();
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::buffers::Game* game_;
  int mode_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LogMessage* other);
  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMessage* New() const final {
    return CreateMaybeMessage<LogMessage>(NULL);
  }

  LogMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogMessage_Severity Severity;
  static const Severity UNKNOWN =
    LogMessage_Severity_UNKNOWN;
  static const Severity FINE =
    LogMessage_Severity_FINE;
  static const Severity INFO =
    LogMessage_Severity_INFO;
  static const Severity WARNING =
    LogMessage_Severity_WARNING;
  static const Severity ERROR =
    LogMessage_Severity_ERROR;
  static inline bool Severity_IsValid(int value) {
    return LogMessage_Severity_IsValid(value);
  }
  static const Severity Severity_MIN =
    LogMessage_Severity_Severity_MIN;
  static const Severity Severity_MAX =
    LogMessage_Severity_Severity_MAX;
  static const int Severity_ARRAYSIZE =
    LogMessage_Severity_Severity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Severity_descriptor() {
    return LogMessage_Severity_descriptor();
  }
  static inline const ::std::string& Severity_Name(Severity value) {
    return LogMessage_Severity_Name(value);
  }
  static inline bool Severity_Parse(const ::std::string& name,
      Severity* value) {
    return LogMessage_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .buffers.LogMessage.Severity severity = 1;
  bool has_severity() const;
  void clear_severity();
  static const int kSeverityFieldNumber = 1;
  ::buffers::LogMessage_Severity severity() const;
  void set_severity(::buffers::LogMessage_Severity value);

  // @@protoc_insertion_point(class_scope:buffers.LogMessage)
 private:
  void set_has_severity();
  void clear_has_severity();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int severity_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProgressMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.ProgressMessage) */ {
 public:
  ProgressMessage();
  virtual ~ProgressMessage();

  ProgressMessage(const ProgressMessage& from);

  inline ProgressMessage& operator=(const ProgressMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProgressMessage(ProgressMessage&& from) noexcept
    : ProgressMessage() {
    *this = ::std::move(from);
  }

  inline ProgressMessage& operator=(ProgressMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProgressMessage* internal_default_instance() {
    return reinterpret_cast<const ProgressMessage*>(
               &_ProgressMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProgressMessage* other);
  friend void swap(ProgressMessage& a, ProgressMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProgressMessage* New() const final {
    return CreateMaybeMessage<ProgressMessage>(NULL);
  }

  ProgressMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProgressMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProgressMessage& from);
  void MergeFrom(const ProgressMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProgressMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional float progress = 1;
  bool has_progress() const;
  void clear_progress();
  static const int kProgressFieldNumber = 1;
  float progress() const;
  void set_progress(float value);

  // @@protoc_insertion_point(class_scope:buffers.ProgressMessage)
 private:
  void set_has_progress();
  void clear_has_progress();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  float progress_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompileReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.CompileReply) */ {
 public:
  CompileReply();
  virtual ~CompileReply();

  CompileReply(const CompileReply& from);

  inline CompileReply& operator=(const CompileReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompileReply(CompileReply&& from) noexcept
    : CompileReply() {
    *this = ::std::move(from);
  }

  inline CompileReply& operator=(CompileReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompileReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompileReply* internal_default_instance() {
    return reinterpret_cast<const CompileReply*>(
               &_CompileReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CompileReply* other);
  friend void swap(CompileReply& a, CompileReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompileReply* New() const final {
    return CreateMaybeMessage<CompileReply>(NULL);
  }

  CompileReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompileReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompileReply& from);
  void MergeFrom(const CompileReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .buffers.LogMessage message = 1;
  int message_size() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  ::buffers::LogMessage* mutable_message(int index);
  ::google::protobuf::RepeatedPtrField< ::buffers::LogMessage >*
      mutable_message();
  const ::buffers::LogMessage& message(int index) const;
  ::buffers::LogMessage* add_message();
  const ::google::protobuf::RepeatedPtrField< ::buffers::LogMessage >&
      message() const;

  // optional .buffers.ProgressMessage progress = 2;
  bool has_progress() const;
  void clear_progress();
  static const int kProgressFieldNumber = 2;
  private:
  const ::buffers::ProgressMessage& _internal_progress() const;
  public:
  const ::buffers::ProgressMessage& progress() const;
  ::buffers::ProgressMessage* release_progress();
  ::buffers::ProgressMessage* mutable_progress();
  void set_allocated_progress(::buffers::ProgressMessage* progress);

  // @@protoc_insertion_point(class_scope:buffers.CompileReply)
 private:
  void set_has_progress();
  void clear_has_progress();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::buffers::LogMessage > message_;
  ::buffers::ProgressMessage* progress_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyntaxError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SyntaxError) */ {
 public:
  SyntaxError();
  virtual ~SyntaxError();

  SyntaxError(const SyntaxError& from);

  inline SyntaxError& operator=(const SyntaxError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyntaxError(SyntaxError&& from) noexcept
    : SyntaxError() {
    *this = ::std::move(from);
  }

  inline SyntaxError& operator=(SyntaxError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyntaxError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyntaxError* internal_default_instance() {
    return reinterpret_cast<const SyntaxError*>(
               &_SyntaxError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SyntaxError* other);
  friend void swap(SyntaxError& a, SyntaxError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyntaxError* New() const final {
    return CreateMaybeMessage<SyntaxError>(NULL);
  }

  SyntaxError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyntaxError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyntaxError& from);
  void MergeFrom(const SyntaxError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyntaxError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 line = 2;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 2;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // optional int32 position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // optional int32 absolute_index = 4;
  bool has_absolute_index() const;
  void clear_absolute_index();
  static const int kAbsoluteIndexFieldNumber = 4;
  ::google::protobuf::int32 absolute_index() const;
  void set_absolute_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.SyntaxError)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_line();
  void clear_has_line();
  void set_has_position();
  void clear_has_position();
  void set_has_absolute_index();
  void clear_has_absolute_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::int32 absolute_index_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetDefinitionsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SetDefinitionsRequest) */ {
 public:
  SetDefinitionsRequest();
  virtual ~SetDefinitionsRequest();

  SetDefinitionsRequest(const SetDefinitionsRequest& from);

  inline SetDefinitionsRequest& operator=(const SetDefinitionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetDefinitionsRequest(SetDefinitionsRequest&& from) noexcept
    : SetDefinitionsRequest() {
    *this = ::std::move(from);
  }

  inline SetDefinitionsRequest& operator=(SetDefinitionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDefinitionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetDefinitionsRequest* internal_default_instance() {
    return reinterpret_cast<const SetDefinitionsRequest*>(
               &_SetDefinitionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SetDefinitionsRequest* other);
  friend void swap(SetDefinitionsRequest& a, SetDefinitionsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetDefinitionsRequest* New() const final {
    return CreateMaybeMessage<SetDefinitionsRequest>(NULL);
  }

  SetDefinitionsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetDefinitionsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetDefinitionsRequest& from);
  void MergeFrom(const SetDefinitionsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDefinitionsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional string yaml = 2;
  bool has_yaml() const;
  void clear_yaml();
  static const int kYamlFieldNumber = 2;
  const ::std::string& yaml() const;
  void set_yaml(const ::std::string& value);
  #if LANG_CXX11
  void set_yaml(::std::string&& value);
  #endif
  void set_yaml(const char* value);
  void set_yaml(const char* value, size_t size);
  ::std::string* mutable_yaml();
  ::std::string* release_yaml();
  void set_allocated_yaml(::std::string* yaml);

  // @@protoc_insertion_point(class_scope:buffers.SetDefinitionsRequest)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_yaml();
  void clear_has_yaml();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr yaml_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetCurrentConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SetCurrentConfigRequest) */ {
 public:
  SetCurrentConfigRequest();
  virtual ~SetCurrentConfigRequest();

  SetCurrentConfigRequest(const SetCurrentConfigRequest& from);

  inline SetCurrentConfigRequest& operator=(const SetCurrentConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetCurrentConfigRequest(SetCurrentConfigRequest&& from) noexcept
    : SetCurrentConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetCurrentConfigRequest& operator=(SetCurrentConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetCurrentConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetCurrentConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetCurrentConfigRequest*>(
               &_SetCurrentConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SetCurrentConfigRequest* other);
  friend void swap(SetCurrentConfigRequest& a, SetCurrentConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetCurrentConfigRequest* New() const final {
    return CreateMaybeMessage<SetCurrentConfigRequest>(NULL);
  }

  SetCurrentConfigRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetCurrentConfigRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetCurrentConfigRequest& from);
  void MergeFrom(const SetCurrentConfigRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCurrentConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .buffers.resources.Settings settings = 1;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 1;
  private:
  const ::buffers::resources::Settings& _internal_settings() const;
  public:
  const ::buffers::resources::Settings& settings() const;
  ::buffers::resources::Settings* release_settings();
  ::buffers::resources::Settings* mutable_settings();
  void set_allocated_settings(::buffers::resources::Settings* settings);

  // @@protoc_insertion_point(class_scope:buffers.SetCurrentConfigRequest)
 private:
  void set_has_settings();
  void clear_has_settings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::buffers::resources::Settings* settings_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyntaxCheckRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SyntaxCheckRequest) */ {
 public:
  SyntaxCheckRequest();
  virtual ~SyntaxCheckRequest();

  SyntaxCheckRequest(const SyntaxCheckRequest& from);

  inline SyntaxCheckRequest& operator=(const SyntaxCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyntaxCheckRequest(SyntaxCheckRequest&& from) noexcept
    : SyntaxCheckRequest() {
    *this = ::std::move(from);
  }

  inline SyntaxCheckRequest& operator=(SyntaxCheckRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyntaxCheckRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyntaxCheckRequest* internal_default_instance() {
    return reinterpret_cast<const SyntaxCheckRequest*>(
               &_SyntaxCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SyntaxCheckRequest* other);
  friend void swap(SyntaxCheckRequest& a, SyntaxCheckRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyntaxCheckRequest* New() const final {
    return CreateMaybeMessage<SyntaxCheckRequest>(NULL);
  }

  SyntaxCheckRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyntaxCheckRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyntaxCheckRequest& from);
  void MergeFrom(const SyntaxCheckRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyntaxCheckRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string script_names = 3;
  int script_names_size() const;
  void clear_script_names();
  static const int kScriptNamesFieldNumber = 3;
  const ::std::string& script_names(int index) const;
  ::std::string* mutable_script_names(int index);
  void set_script_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_script_names(int index, ::std::string&& value);
  #endif
  void set_script_names(int index, const char* value);
  void set_script_names(int index, const char* value, size_t size);
  ::std::string* add_script_names();
  void add_script_names(const ::std::string& value);
  #if LANG_CXX11
  void add_script_names(::std::string&& value);
  #endif
  void add_script_names(const char* value);
  void add_script_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& script_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_script_names();

  // optional string code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional int32 script_count = 2;
  bool has_script_count() const;
  void clear_script_count();
  static const int kScriptCountFieldNumber = 2;
  ::google::protobuf::int32 script_count() const;
  void set_script_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.SyntaxCheckRequest)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_script_count();
  void clear_has_script_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> script_names_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::int32 script_count_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SystemType) */ {
 public:
  SystemType();
  virtual ~SystemType();

  SystemType(const SystemType& from);

  inline SystemType& operator=(const SystemType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemType(SystemType&& from) noexcept
    : SystemType() {
    *this = ::std::move(from);
  }

  inline SystemType& operator=(SystemType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemType* internal_default_instance() {
    return reinterpret_cast<const SystemType*>(
               &_SystemType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SystemType* other);
  friend void swap(SystemType& a, SystemType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemType* New() const final {
    return CreateMaybeMessage<SystemType>(NULL);
  }

  SystemType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SystemType& from);
  void MergeFrom(const SystemType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .buffers.SystemInfo subsystems = 2;
  int subsystems_size() const;
  void clear_subsystems();
  static const int kSubsystemsFieldNumber = 2;
  ::buffers::SystemInfo* mutable_subsystems(int index);
  ::google::protobuf::RepeatedPtrField< ::buffers::SystemInfo >*
      mutable_subsystems();
  const ::buffers::SystemInfo& subsystems(int index) const;
  ::buffers::SystemInfo* add_subsystems();
  const ::google::protobuf::RepeatedPtrField< ::buffers::SystemInfo >&
      subsystems() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:buffers.SystemType)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::buffers::SystemInfo > subsystems_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.SystemInfo) */ {
 public:
  SystemInfo();
  virtual ~SystemInfo();

  SystemInfo(const SystemInfo& from);

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemInfo(SystemInfo&& from) noexcept
    : SystemInfo() {
    *this = ::std::move(from);
  }

  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SystemInfo* other);
  friend void swap(SystemInfo& a, SystemInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemInfo* New() const final {
    return CreateMaybeMessage<SystemInfo>(NULL);
  }

  SystemInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string author = 4;
  bool has_author() const;
  void clear_author();
  static const int kAuthorFieldNumber = 4;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // optional string target = 5;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 5;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // @@protoc_insertion_point(class_scope:buffers.SystemInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_description();
  void clear_has_description();
  void set_has_author();
  void clear_has_author();
  void set_has_target();
  void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  friend struct ::protobuf_server_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Resource

// optional string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.name)
  return name_.GetNoArena();
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.Resource.name)
}
#if LANG_CXX11
inline void Resource::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.Resource.name)
}
#endif
inline void Resource::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.Resource.name)
}
inline void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.Resource.name)
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.Resource.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:buffers.Resource.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.Resource.name)
}

// optional bool is_function = 2;
inline bool Resource::has_is_function() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_is_function() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_is_function() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_is_function() {
  is_function_ = false;
  clear_has_is_function();
}
inline bool Resource::is_function() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.is_function)
  return is_function_;
}
inline void Resource::set_is_function(bool value) {
  set_has_is_function();
  is_function_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.is_function)
}

// optional int32 arg_count_min = 3;
inline bool Resource::has_arg_count_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_arg_count_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_arg_count_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_arg_count_min() {
  arg_count_min_ = 0;
  clear_has_arg_count_min();
}
inline ::google::protobuf::int32 Resource::arg_count_min() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.arg_count_min)
  return arg_count_min_;
}
inline void Resource::set_arg_count_min(::google::protobuf::int32 value) {
  set_has_arg_count_min();
  arg_count_min_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.arg_count_min)
}

// optional int32 arg_count_max = 4;
inline bool Resource::has_arg_count_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_arg_count_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_arg_count_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_arg_count_max() {
  arg_count_max_ = 0;
  clear_has_arg_count_max();
}
inline ::google::protobuf::int32 Resource::arg_count_max() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.arg_count_max)
  return arg_count_max_;
}
inline void Resource::set_arg_count_max(::google::protobuf::int32 value) {
  set_has_arg_count_max();
  arg_count_max_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.arg_count_max)
}

// optional int32 overload_count = 5;
inline bool Resource::has_overload_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_overload_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_overload_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_overload_count() {
  overload_count_ = 0;
  clear_has_overload_count();
}
inline ::google::protobuf::int32 Resource::overload_count() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.overload_count)
  return overload_count_;
}
inline void Resource::set_overload_count(::google::protobuf::int32 value) {
  set_has_overload_count();
  overload_count_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.overload_count)
}

// optional int32 is_type_name = 6;
inline bool Resource::has_is_type_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Resource::set_has_is_type_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Resource::clear_has_is_type_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Resource::clear_is_type_name() {
  is_type_name_ = 0;
  clear_has_is_type_name();
}
inline ::google::protobuf::int32 Resource::is_type_name() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.is_type_name)
  return is_type_name_;
}
inline void Resource::set_is_type_name(::google::protobuf::int32 value) {
  set_has_is_type_name();
  is_type_name_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.is_type_name)
}

// optional int32 is_global = 7;
inline bool Resource::has_is_global() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Resource::set_has_is_global() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Resource::clear_has_is_global() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Resource::clear_is_global() {
  is_global_ = 0;
  clear_has_is_global();
}
inline ::google::protobuf::int32 Resource::is_global() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.is_global)
  return is_global_;
}
inline void Resource::set_is_global(::google::protobuf::int32 value) {
  set_has_is_global();
  is_global_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.is_global)
}

// optional bool is_end = 8;
inline bool Resource::has_is_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_is_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_is_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_is_end() {
  is_end_ = false;
  clear_has_is_end();
}
inline bool Resource::is_end() const {
  // @@protoc_insertion_point(field_get:buffers.Resource.is_end)
  return is_end_;
}
inline void Resource::set_is_end(bool value) {
  set_has_is_end();
  is_end_ = value;
  // @@protoc_insertion_point(field_set:buffers.Resource.is_end)
}

// repeated string parameters = 9;
inline int Resource::parameters_size() const {
  return parameters_.size();
}
inline void Resource::clear_parameters() {
  parameters_.Clear();
}
inline const ::std::string& Resource::parameters(int index) const {
  // @@protoc_insertion_point(field_get:buffers.Resource.parameters)
  return parameters_.Get(index);
}
inline ::std::string* Resource::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.Resource.parameters)
  return parameters_.Mutable(index);
}
inline void Resource::set_parameters(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:buffers.Resource.parameters)
  parameters_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Resource::set_parameters(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:buffers.Resource.parameters)
  parameters_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Resource::set_parameters(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  parameters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffers.Resource.parameters)
}
inline void Resource::set_parameters(int index, const char* value, size_t size) {
  parameters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffers.Resource.parameters)
}
inline ::std::string* Resource::add_parameters() {
  // @@protoc_insertion_point(field_add_mutable:buffers.Resource.parameters)
  return parameters_.Add();
}
inline void Resource::add_parameters(const ::std::string& value) {
  parameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffers.Resource.parameters)
}
#if LANG_CXX11
inline void Resource::add_parameters(::std::string&& value) {
  parameters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffers.Resource.parameters)
}
#endif
inline void Resource::add_parameters(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  parameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffers.Resource.parameters)
}
inline void Resource::add_parameters(const char* value, size_t size) {
  parameters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffers.Resource.parameters)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Resource::parameters() const {
  // @@protoc_insertion_point(field_list:buffers.Resource.parameters)
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Resource::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:buffers.Resource.parameters)
  return &parameters_;
}

// -------------------------------------------------------------------

// CompileRequest

// optional .buffers.Game game = 1;
inline bool CompileRequest::has_game() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompileRequest::set_has_game() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompileRequest::clear_has_game() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::buffers::Game& CompileRequest::_internal_game() const {
  return *game_;
}
inline const ::buffers::Game& CompileRequest::game() const {
  const ::buffers::Game* p = game_;
  // @@protoc_insertion_point(field_get:buffers.CompileRequest.game)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::Game*>(
      &::buffers::_Game_default_instance_);
}
inline ::buffers::Game* CompileRequest::release_game() {
  // @@protoc_insertion_point(field_release:buffers.CompileRequest.game)
  clear_has_game();
  ::buffers::Game* temp = game_;
  game_ = NULL;
  return temp;
}
inline ::buffers::Game* CompileRequest::mutable_game() {
  set_has_game();
  if (game_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::Game>(GetArenaNoVirtual());
    game_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.CompileRequest.game)
  return game_;
}
inline void CompileRequest::set_allocated_game(::buffers::Game* game) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(game_);
  }
  if (game) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game, submessage_arena);
    }
    set_has_game();
  } else {
    clear_has_game();
  }
  game_ = game;
  // @@protoc_insertion_point(field_set_allocated:buffers.CompileRequest.game)
}

// optional string name = 2;
inline bool CompileRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompileRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompileRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompileRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CompileRequest::name() const {
  // @@protoc_insertion_point(field_get:buffers.CompileRequest.name)
  return name_.GetNoArena();
}
inline void CompileRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.CompileRequest.name)
}
#if LANG_CXX11
inline void CompileRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.CompileRequest.name)
}
#endif
inline void CompileRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.CompileRequest.name)
}
inline void CompileRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.CompileRequest.name)
}
inline ::std::string* CompileRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.CompileRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompileRequest::release_name() {
  // @@protoc_insertion_point(field_release:buffers.CompileRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompileRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.CompileRequest.name)
}

// optional .buffers.CompileRequest.CompileMode mode = 3;
inline bool CompileRequest::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompileRequest::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompileRequest::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompileRequest::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::buffers::CompileRequest_CompileMode CompileRequest::mode() const {
  // @@protoc_insertion_point(field_get:buffers.CompileRequest.mode)
  return static_cast< ::buffers::CompileRequest_CompileMode >(mode_);
}
inline void CompileRequest::set_mode(::buffers::CompileRequest_CompileMode value) {
  assert(::buffers::CompileRequest_CompileMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:buffers.CompileRequest.mode)
}

// -------------------------------------------------------------------

// LogMessage

// optional .buffers.LogMessage.Severity severity = 1;
inline bool LogMessage::has_severity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogMessage::set_has_severity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogMessage::clear_has_severity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogMessage::clear_severity() {
  severity_ = 0;
  clear_has_severity();
}
inline ::buffers::LogMessage_Severity LogMessage::severity() const {
  // @@protoc_insertion_point(field_get:buffers.LogMessage.severity)
  return static_cast< ::buffers::LogMessage_Severity >(severity_);
}
inline void LogMessage::set_severity(::buffers::LogMessage_Severity value) {
  assert(::buffers::LogMessage_Severity_IsValid(value));
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:buffers.LogMessage.severity)
}

// optional string message = 2;
inline bool LogMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:buffers.LogMessage.message)
  return message_.GetNoArena();
}
inline void LogMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.LogMessage.message)
}
#if LANG_CXX11
inline void LogMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.LogMessage.message)
}
#endif
inline void LogMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:buffers.LogMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:buffers.LogMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:buffers.LogMessage.message)
}

// -------------------------------------------------------------------

// ProgressMessage

// optional float progress = 1;
inline bool ProgressMessage::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProgressMessage::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProgressMessage::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProgressMessage::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float ProgressMessage::progress() const {
  // @@protoc_insertion_point(field_get:buffers.ProgressMessage.progress)
  return progress_;
}
inline void ProgressMessage::set_progress(float value) {
  set_has_progress();
  progress_ = value;
  // @@protoc_insertion_point(field_set:buffers.ProgressMessage.progress)
}

// optional string message = 2;
inline bool ProgressMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgressMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgressMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgressMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ProgressMessage::message() const {
  // @@protoc_insertion_point(field_get:buffers.ProgressMessage.message)
  return message_.GetNoArena();
}
inline void ProgressMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.ProgressMessage.message)
}
#if LANG_CXX11
inline void ProgressMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.ProgressMessage.message)
}
#endif
inline void ProgressMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.ProgressMessage.message)
}
inline void ProgressMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.ProgressMessage.message)
}
inline ::std::string* ProgressMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:buffers.ProgressMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProgressMessage::release_message() {
  // @@protoc_insertion_point(field_release:buffers.ProgressMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProgressMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:buffers.ProgressMessage.message)
}

// -------------------------------------------------------------------

// CompileReply

// repeated .buffers.LogMessage message = 1;
inline int CompileReply::message_size() const {
  return message_.size();
}
inline void CompileReply::clear_message() {
  message_.Clear();
}
inline ::buffers::LogMessage* CompileReply::mutable_message(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.CompileReply.message)
  return message_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::LogMessage >*
CompileReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable_list:buffers.CompileReply.message)
  return &message_;
}
inline const ::buffers::LogMessage& CompileReply::message(int index) const {
  // @@protoc_insertion_point(field_get:buffers.CompileReply.message)
  return message_.Get(index);
}
inline ::buffers::LogMessage* CompileReply::add_message() {
  // @@protoc_insertion_point(field_add:buffers.CompileReply.message)
  return message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::LogMessage >&
CompileReply::message() const {
  // @@protoc_insertion_point(field_list:buffers.CompileReply.message)
  return message_;
}

// optional .buffers.ProgressMessage progress = 2;
inline bool CompileReply::has_progress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompileReply::set_has_progress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompileReply::clear_has_progress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompileReply::clear_progress() {
  if (progress_ != NULL) progress_->Clear();
  clear_has_progress();
}
inline const ::buffers::ProgressMessage& CompileReply::_internal_progress() const {
  return *progress_;
}
inline const ::buffers::ProgressMessage& CompileReply::progress() const {
  const ::buffers::ProgressMessage* p = progress_;
  // @@protoc_insertion_point(field_get:buffers.CompileReply.progress)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::ProgressMessage*>(
      &::buffers::_ProgressMessage_default_instance_);
}
inline ::buffers::ProgressMessage* CompileReply::release_progress() {
  // @@protoc_insertion_point(field_release:buffers.CompileReply.progress)
  clear_has_progress();
  ::buffers::ProgressMessage* temp = progress_;
  progress_ = NULL;
  return temp;
}
inline ::buffers::ProgressMessage* CompileReply::mutable_progress() {
  set_has_progress();
  if (progress_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::ProgressMessage>(GetArenaNoVirtual());
    progress_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.CompileReply.progress)
  return progress_;
}
inline void CompileReply::set_allocated_progress(::buffers::ProgressMessage* progress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete progress_;
  }
  if (progress) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      progress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    set_has_progress();
  } else {
    clear_has_progress();
  }
  progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:buffers.CompileReply.progress)
}

// -------------------------------------------------------------------

// SyntaxError

// optional string message = 1;
inline bool SyntaxError::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyntaxError::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyntaxError::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyntaxError::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& SyntaxError::message() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxError.message)
  return message_.GetNoArena();
}
inline void SyntaxError::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SyntaxError.message)
}
#if LANG_CXX11
inline void SyntaxError::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SyntaxError.message)
}
#endif
inline void SyntaxError::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SyntaxError.message)
}
inline void SyntaxError::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SyntaxError.message)
}
inline ::std::string* SyntaxError::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:buffers.SyntaxError.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SyntaxError::release_message() {
  // @@protoc_insertion_point(field_release:buffers.SyntaxError.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SyntaxError::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:buffers.SyntaxError.message)
}

// optional int32 line = 2;
inline bool SyntaxError::has_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyntaxError::set_has_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyntaxError::clear_has_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyntaxError::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 SyntaxError::line() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxError.line)
  return line_;
}
inline void SyntaxError::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:buffers.SyntaxError.line)
}

// optional int32 position = 3;
inline bool SyntaxError::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyntaxError::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyntaxError::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyntaxError::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 SyntaxError::position() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxError.position)
  return position_;
}
inline void SyntaxError::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:buffers.SyntaxError.position)
}

// optional int32 absolute_index = 4;
inline bool SyntaxError::has_absolute_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyntaxError::set_has_absolute_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyntaxError::clear_has_absolute_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyntaxError::clear_absolute_index() {
  absolute_index_ = 0;
  clear_has_absolute_index();
}
inline ::google::protobuf::int32 SyntaxError::absolute_index() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxError.absolute_index)
  return absolute_index_;
}
inline void SyntaxError::set_absolute_index(::google::protobuf::int32 value) {
  set_has_absolute_index();
  absolute_index_ = value;
  // @@protoc_insertion_point(field_set:buffers.SyntaxError.absolute_index)
}

// -------------------------------------------------------------------

// SetDefinitionsRequest

// optional string code = 1;
inline bool SetDefinitionsRequest::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDefinitionsRequest::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDefinitionsRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDefinitionsRequest::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& SetDefinitionsRequest::code() const {
  // @@protoc_insertion_point(field_get:buffers.SetDefinitionsRequest.code)
  return code_.GetNoArena();
}
inline void SetDefinitionsRequest::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SetDefinitionsRequest.code)
}
#if LANG_CXX11
inline void SetDefinitionsRequest::set_code(::std::string&& value) {
  set_has_code();
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SetDefinitionsRequest.code)
}
#endif
inline void SetDefinitionsRequest::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SetDefinitionsRequest.code)
}
inline void SetDefinitionsRequest::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SetDefinitionsRequest.code)
}
inline ::std::string* SetDefinitionsRequest::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:buffers.SetDefinitionsRequest.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetDefinitionsRequest::release_code() {
  // @@protoc_insertion_point(field_release:buffers.SetDefinitionsRequest.code)
  if (!has_code()) {
    return NULL;
  }
  clear_has_code();
  return code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetDefinitionsRequest::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:buffers.SetDefinitionsRequest.code)
}

// optional string yaml = 2;
inline bool SetDefinitionsRequest::has_yaml() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetDefinitionsRequest::set_has_yaml() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetDefinitionsRequest::clear_has_yaml() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetDefinitionsRequest::clear_yaml() {
  yaml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_yaml();
}
inline const ::std::string& SetDefinitionsRequest::yaml() const {
  // @@protoc_insertion_point(field_get:buffers.SetDefinitionsRequest.yaml)
  return yaml_.GetNoArena();
}
inline void SetDefinitionsRequest::set_yaml(const ::std::string& value) {
  set_has_yaml();
  yaml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SetDefinitionsRequest.yaml)
}
#if LANG_CXX11
inline void SetDefinitionsRequest::set_yaml(::std::string&& value) {
  set_has_yaml();
  yaml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SetDefinitionsRequest.yaml)
}
#endif
inline void SetDefinitionsRequest::set_yaml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_yaml();
  yaml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SetDefinitionsRequest.yaml)
}
inline void SetDefinitionsRequest::set_yaml(const char* value, size_t size) {
  set_has_yaml();
  yaml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SetDefinitionsRequest.yaml)
}
inline ::std::string* SetDefinitionsRequest::mutable_yaml() {
  set_has_yaml();
  // @@protoc_insertion_point(field_mutable:buffers.SetDefinitionsRequest.yaml)
  return yaml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetDefinitionsRequest::release_yaml() {
  // @@protoc_insertion_point(field_release:buffers.SetDefinitionsRequest.yaml)
  if (!has_yaml()) {
    return NULL;
  }
  clear_has_yaml();
  return yaml_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetDefinitionsRequest::set_allocated_yaml(::std::string* yaml) {
  if (yaml != NULL) {
    set_has_yaml();
  } else {
    clear_has_yaml();
  }
  yaml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), yaml);
  // @@protoc_insertion_point(field_set_allocated:buffers.SetDefinitionsRequest.yaml)
}

// -------------------------------------------------------------------

// SetCurrentConfigRequest

// optional .buffers.resources.Settings settings = 1;
inline bool SetCurrentConfigRequest::has_settings() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetCurrentConfigRequest::set_has_settings() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetCurrentConfigRequest::clear_has_settings() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::buffers::resources::Settings& SetCurrentConfigRequest::_internal_settings() const {
  return *settings_;
}
inline const ::buffers::resources::Settings& SetCurrentConfigRequest::settings() const {
  const ::buffers::resources::Settings* p = settings_;
  // @@protoc_insertion_point(field_get:buffers.SetCurrentConfigRequest.settings)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Settings*>(
      &::buffers::resources::_Settings_default_instance_);
}
inline ::buffers::resources::Settings* SetCurrentConfigRequest::release_settings() {
  // @@protoc_insertion_point(field_release:buffers.SetCurrentConfigRequest.settings)
  clear_has_settings();
  ::buffers::resources::Settings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline ::buffers::resources::Settings* SetCurrentConfigRequest::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Settings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.SetCurrentConfigRequest.settings)
  return settings_;
}
inline void SetCurrentConfigRequest::set_allocated_settings(::buffers::resources::Settings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(settings_);
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    set_has_settings();
  } else {
    clear_has_settings();
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:buffers.SetCurrentConfigRequest.settings)
}

// -------------------------------------------------------------------

// SyntaxCheckRequest

// optional string code = 1;
inline bool SyntaxCheckRequest::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyntaxCheckRequest::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyntaxCheckRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyntaxCheckRequest::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& SyntaxCheckRequest::code() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxCheckRequest.code)
  return code_.GetNoArena();
}
inline void SyntaxCheckRequest::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SyntaxCheckRequest.code)
}
#if LANG_CXX11
inline void SyntaxCheckRequest::set_code(::std::string&& value) {
  set_has_code();
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SyntaxCheckRequest.code)
}
#endif
inline void SyntaxCheckRequest::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SyntaxCheckRequest.code)
}
inline void SyntaxCheckRequest::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SyntaxCheckRequest.code)
}
inline ::std::string* SyntaxCheckRequest::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:buffers.SyntaxCheckRequest.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SyntaxCheckRequest::release_code() {
  // @@protoc_insertion_point(field_release:buffers.SyntaxCheckRequest.code)
  if (!has_code()) {
    return NULL;
  }
  clear_has_code();
  return code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SyntaxCheckRequest::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:buffers.SyntaxCheckRequest.code)
}

// optional int32 script_count = 2;
inline bool SyntaxCheckRequest::has_script_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyntaxCheckRequest::set_has_script_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyntaxCheckRequest::clear_has_script_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyntaxCheckRequest::clear_script_count() {
  script_count_ = 0;
  clear_has_script_count();
}
inline ::google::protobuf::int32 SyntaxCheckRequest::script_count() const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxCheckRequest.script_count)
  return script_count_;
}
inline void SyntaxCheckRequest::set_script_count(::google::protobuf::int32 value) {
  set_has_script_count();
  script_count_ = value;
  // @@protoc_insertion_point(field_set:buffers.SyntaxCheckRequest.script_count)
}

// repeated string script_names = 3;
inline int SyntaxCheckRequest::script_names_size() const {
  return script_names_.size();
}
inline void SyntaxCheckRequest::clear_script_names() {
  script_names_.Clear();
}
inline const ::std::string& SyntaxCheckRequest::script_names(int index) const {
  // @@protoc_insertion_point(field_get:buffers.SyntaxCheckRequest.script_names)
  return script_names_.Get(index);
}
inline ::std::string* SyntaxCheckRequest::mutable_script_names(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.SyntaxCheckRequest.script_names)
  return script_names_.Mutable(index);
}
inline void SyntaxCheckRequest::set_script_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:buffers.SyntaxCheckRequest.script_names)
  script_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SyntaxCheckRequest::set_script_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:buffers.SyntaxCheckRequest.script_names)
  script_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SyntaxCheckRequest::set_script_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  script_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffers.SyntaxCheckRequest.script_names)
}
inline void SyntaxCheckRequest::set_script_names(int index, const char* value, size_t size) {
  script_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffers.SyntaxCheckRequest.script_names)
}
inline ::std::string* SyntaxCheckRequest::add_script_names() {
  // @@protoc_insertion_point(field_add_mutable:buffers.SyntaxCheckRequest.script_names)
  return script_names_.Add();
}
inline void SyntaxCheckRequest::add_script_names(const ::std::string& value) {
  script_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffers.SyntaxCheckRequest.script_names)
}
#if LANG_CXX11
inline void SyntaxCheckRequest::add_script_names(::std::string&& value) {
  script_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffers.SyntaxCheckRequest.script_names)
}
#endif
inline void SyntaxCheckRequest::add_script_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  script_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffers.SyntaxCheckRequest.script_names)
}
inline void SyntaxCheckRequest::add_script_names(const char* value, size_t size) {
  script_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffers.SyntaxCheckRequest.script_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SyntaxCheckRequest::script_names() const {
  // @@protoc_insertion_point(field_list:buffers.SyntaxCheckRequest.script_names)
  return script_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SyntaxCheckRequest::mutable_script_names() {
  // @@protoc_insertion_point(field_mutable_list:buffers.SyntaxCheckRequest.script_names)
  return &script_names_;
}

// -------------------------------------------------------------------

// SystemType

// optional string name = 1;
inline bool SystemType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SystemType::name() const {
  // @@protoc_insertion_point(field_get:buffers.SystemType.name)
  return name_.GetNoArena();
}
inline void SystemType::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemType.name)
}
#if LANG_CXX11
inline void SystemType::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemType.name)
}
#endif
inline void SystemType::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemType.name)
}
inline void SystemType::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemType.name)
}
inline ::std::string* SystemType::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.SystemType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemType::release_name() {
  // @@protoc_insertion_point(field_release:buffers.SystemType.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemType::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemType.name)
}

// repeated .buffers.SystemInfo subsystems = 2;
inline int SystemType::subsystems_size() const {
  return subsystems_.size();
}
inline void SystemType::clear_subsystems() {
  subsystems_.Clear();
}
inline ::buffers::SystemInfo* SystemType::mutable_subsystems(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.SystemType.subsystems)
  return subsystems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::SystemInfo >*
SystemType::mutable_subsystems() {
  // @@protoc_insertion_point(field_mutable_list:buffers.SystemType.subsystems)
  return &subsystems_;
}
inline const ::buffers::SystemInfo& SystemType::subsystems(int index) const {
  // @@protoc_insertion_point(field_get:buffers.SystemType.subsystems)
  return subsystems_.Get(index);
}
inline ::buffers::SystemInfo* SystemType::add_subsystems() {
  // @@protoc_insertion_point(field_add:buffers.SystemType.subsystems)
  return subsystems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::SystemInfo >&
SystemType::subsystems() const {
  // @@protoc_insertion_point(field_list:buffers.SystemType.subsystems)
  return subsystems_;
}

// -------------------------------------------------------------------

// SystemInfo

// optional string name = 1;
inline bool SystemInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SystemInfo::name() const {
  // @@protoc_insertion_point(field_get:buffers.SystemInfo.name)
  return name_.GetNoArena();
}
inline void SystemInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemInfo.name)
}
#if LANG_CXX11
inline void SystemInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemInfo.name)
}
#endif
inline void SystemInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemInfo.name)
}
inline void SystemInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemInfo.name)
}
inline ::std::string* SystemInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.SystemInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemInfo::release_name() {
  // @@protoc_insertion_point(field_release:buffers.SystemInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemInfo.name)
}

// optional string id = 2;
inline bool SystemInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& SystemInfo::id() const {
  // @@protoc_insertion_point(field_get:buffers.SystemInfo.id)
  return id_.GetNoArena();
}
inline void SystemInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemInfo.id)
}
#if LANG_CXX11
inline void SystemInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemInfo.id)
}
#endif
inline void SystemInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemInfo.id)
}
inline void SystemInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemInfo.id)
}
inline ::std::string* SystemInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:buffers.SystemInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemInfo::release_id() {
  // @@protoc_insertion_point(field_release:buffers.SystemInfo.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemInfo.id)
}

// optional string description = 3;
inline bool SystemInfo::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemInfo::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemInfo::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& SystemInfo::description() const {
  // @@protoc_insertion_point(field_get:buffers.SystemInfo.description)
  return description_.GetNoArena();
}
inline void SystemInfo::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemInfo.description)
}
#if LANG_CXX11
inline void SystemInfo::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemInfo.description)
}
#endif
inline void SystemInfo::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemInfo.description)
}
inline void SystemInfo::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemInfo.description)
}
inline ::std::string* SystemInfo::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:buffers.SystemInfo.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemInfo::release_description() {
  // @@protoc_insertion_point(field_release:buffers.SystemInfo.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemInfo::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemInfo.description)
}

// optional string author = 4;
inline bool SystemInfo::has_author() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemInfo::set_has_author() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemInfo::clear_has_author() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemInfo::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_author();
}
inline const ::std::string& SystemInfo::author() const {
  // @@protoc_insertion_point(field_get:buffers.SystemInfo.author)
  return author_.GetNoArena();
}
inline void SystemInfo::set_author(const ::std::string& value) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemInfo.author)
}
#if LANG_CXX11
inline void SystemInfo::set_author(::std::string&& value) {
  set_has_author();
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemInfo.author)
}
#endif
inline void SystemInfo::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemInfo.author)
}
inline void SystemInfo::set_author(const char* value, size_t size) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemInfo.author)
}
inline ::std::string* SystemInfo::mutable_author() {
  set_has_author();
  // @@protoc_insertion_point(field_mutable:buffers.SystemInfo.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemInfo::release_author() {
  // @@protoc_insertion_point(field_release:buffers.SystemInfo.author)
  if (!has_author()) {
    return NULL;
  }
  clear_has_author();
  return author_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemInfo::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    set_has_author();
  } else {
    clear_has_author();
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemInfo.author)
}

// optional string target = 5;
inline bool SystemInfo::has_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SystemInfo::set_has_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SystemInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SystemInfo::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target();
}
inline const ::std::string& SystemInfo::target() const {
  // @@protoc_insertion_point(field_get:buffers.SystemInfo.target)
  return target_.GetNoArena();
}
inline void SystemInfo::set_target(const ::std::string& value) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.SystemInfo.target)
}
#if LANG_CXX11
inline void SystemInfo::set_target(::std::string&& value) {
  set_has_target();
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.SystemInfo.target)
}
#endif
inline void SystemInfo::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.SystemInfo.target)
}
inline void SystemInfo::set_target(const char* value, size_t size) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.SystemInfo.target)
}
inline ::std::string* SystemInfo::mutable_target() {
  set_has_target();
  // @@protoc_insertion_point(field_mutable:buffers.SystemInfo.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemInfo::release_target() {
  // @@protoc_insertion_point(field_release:buffers.SystemInfo.target)
  if (!has_target()) {
    return NULL;
  }
  clear_has_target();
  return target_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemInfo::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    set_has_target();
  } else {
    clear_has_target();
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:buffers.SystemInfo.target)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace buffers

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::buffers::CompileRequest_CompileMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::buffers::CompileRequest_CompileMode>() {
  return ::buffers::CompileRequest_CompileMode_descriptor();
}
template <> struct is_proto_enum< ::buffers::LogMessage_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::buffers::LogMessage_Severity>() {
  return ::buffers::LogMessage_Severity_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_server_2eproto
