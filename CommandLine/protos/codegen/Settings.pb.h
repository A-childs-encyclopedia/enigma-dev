// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Settings.proto

#ifndef PROTOBUF_INCLUDED_Settings_2eproto
#define PROTOBUF_INCLUDED_Settings_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Settings_2eproto 

namespace protobuf_Settings_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Settings_2eproto
namespace buffers {
namespace resources {
class API;
class APIDefaultTypeInternal;
extern APIDefaultTypeInternal _API_default_instance_;
class Compiler;
class CompilerDefaultTypeInternal;
extern CompilerDefaultTypeInternal _Compiler_default_instance_;
class Deployment;
class DeploymentDefaultTypeInternal;
extern DeploymentDefaultTypeInternal _Deployment_default_instance_;
class General;
class GeneralDefaultTypeInternal;
extern GeneralDefaultTypeInternal _General_default_instance_;
class Graphics;
class GraphicsDefaultTypeInternal;
extern GraphicsDefaultTypeInternal _Graphics_default_instance_;
class Info;
class InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class Installer;
class InstallerDefaultTypeInternal;
extern InstallerDefaultTypeInternal _Installer_default_instance_;
class Settings;
class SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
}  // namespace resources
}  // namespace buffers
namespace google {
namespace protobuf {
template<> ::buffers::resources::API* Arena::CreateMaybeMessage<::buffers::resources::API>(Arena*);
template<> ::buffers::resources::Compiler* Arena::CreateMaybeMessage<::buffers::resources::Compiler>(Arena*);
template<> ::buffers::resources::Deployment* Arena::CreateMaybeMessage<::buffers::resources::Deployment>(Arena*);
template<> ::buffers::resources::General* Arena::CreateMaybeMessage<::buffers::resources::General>(Arena*);
template<> ::buffers::resources::Graphics* Arena::CreateMaybeMessage<::buffers::resources::Graphics>(Arena*);
template<> ::buffers::resources::Info* Arena::CreateMaybeMessage<::buffers::resources::Info>(Arena*);
template<> ::buffers::resources::Installer* Arena::CreateMaybeMessage<::buffers::resources::Installer>(Arena*);
template<> ::buffers::resources::Settings* Arena::CreateMaybeMessage<::buffers::resources::Settings>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace buffers {
namespace resources {

enum Graphics_VertexBufferMethod {
  Graphics_VertexBufferMethod_FAST = 0,
  Graphics_VertexBufferMethod_COMPATIBLE = 1,
  Graphics_VertexBufferMethod_MOST_COMPATIBLE = 2
};
bool Graphics_VertexBufferMethod_IsValid(int value);
const Graphics_VertexBufferMethod Graphics_VertexBufferMethod_VertexBufferMethod_MIN = Graphics_VertexBufferMethod_FAST;
const Graphics_VertexBufferMethod Graphics_VertexBufferMethod_VertexBufferMethod_MAX = Graphics_VertexBufferMethod_MOST_COMPATIBLE;
const int Graphics_VertexBufferMethod_VertexBufferMethod_ARRAYSIZE = Graphics_VertexBufferMethod_VertexBufferMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Graphics_VertexBufferMethod_descriptor();
inline const ::std::string& Graphics_VertexBufferMethod_Name(Graphics_VertexBufferMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Graphics_VertexBufferMethod_descriptor(), value);
}
inline bool Graphics_VertexBufferMethod_Parse(
    const ::std::string& name, Graphics_VertexBufferMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Graphics_VertexBufferMethod>(
    Graphics_VertexBufferMethod_descriptor(), name, value);
}
// ===================================================================

class Settings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Settings) */ {
 public:
  Settings();
  virtual ~Settings();

  Settings(const Settings& from);

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(Settings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Settings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Settings* other);
  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Settings* New() const final {
    return CreateMaybeMessage<Settings>(NULL);
  }

  Settings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Settings& from);
  void MergeFrom(const Settings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Settings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .buffers.resources.API api = 1;
  bool has_api() const;
  void clear_api();
  static const int kApiFieldNumber = 1;
  private:
  const ::buffers::resources::API& _internal_api() const;
  public:
  const ::buffers::resources::API& api() const;
  ::buffers::resources::API* release_api();
  ::buffers::resources::API* mutable_api();
  void set_allocated_api(::buffers::resources::API* api);

  // optional .buffers.resources.Compiler compiler = 2;
  bool has_compiler() const;
  void clear_compiler();
  static const int kCompilerFieldNumber = 2;
  private:
  const ::buffers::resources::Compiler& _internal_compiler() const;
  public:
  const ::buffers::resources::Compiler& compiler() const;
  ::buffers::resources::Compiler* release_compiler();
  ::buffers::resources::Compiler* mutable_compiler();
  void set_allocated_compiler(::buffers::resources::Compiler* compiler);

  // optional .buffers.resources.General general = 3;
  bool has_general() const;
  void clear_general();
  static const int kGeneralFieldNumber = 3;
  private:
  const ::buffers::resources::General& _internal_general() const;
  public:
  const ::buffers::resources::General& general() const;
  ::buffers::resources::General* release_general();
  ::buffers::resources::General* mutable_general();
  void set_allocated_general(::buffers::resources::General* general);

  // optional .buffers.resources.Graphics graphics = 4;
  bool has_graphics() const;
  void clear_graphics();
  static const int kGraphicsFieldNumber = 4;
  private:
  const ::buffers::resources::Graphics& _internal_graphics() const;
  public:
  const ::buffers::resources::Graphics& graphics() const;
  ::buffers::resources::Graphics* release_graphics();
  ::buffers::resources::Graphics* mutable_graphics();
  void set_allocated_graphics(::buffers::resources::Graphics* graphics);

  // optional .buffers.resources.Info info = 5;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 5;
  private:
  const ::buffers::resources::Info& _internal_info() const;
  public:
  const ::buffers::resources::Info& info() const;
  ::buffers::resources::Info* release_info();
  ::buffers::resources::Info* mutable_info();
  void set_allocated_info(::buffers::resources::Info* info);

  // optional .buffers.resources.Installer installer = 6;
  bool has_installer() const;
  void clear_installer();
  static const int kInstallerFieldNumber = 6;
  private:
  const ::buffers::resources::Installer& _internal_installer() const;
  public:
  const ::buffers::resources::Installer& installer() const;
  ::buffers::resources::Installer* release_installer();
  ::buffers::resources::Installer* mutable_installer();
  void set_allocated_installer(::buffers::resources::Installer* installer);

  // optional .buffers.resources.Deployment deployment = 7;
  bool has_deployment() const;
  void clear_deployment();
  static const int kDeploymentFieldNumber = 7;
  private:
  const ::buffers::resources::Deployment& _internal_deployment() const;
  public:
  const ::buffers::resources::Deployment& deployment() const;
  ::buffers::resources::Deployment* release_deployment();
  ::buffers::resources::Deployment* mutable_deployment();
  void set_allocated_deployment(::buffers::resources::Deployment* deployment);

  // @@protoc_insertion_point(class_scope:buffers.resources.Settings)
 private:
  void set_has_api();
  void clear_has_api();
  void set_has_compiler();
  void clear_has_compiler();
  void set_has_general();
  void clear_has_general();
  void set_has_graphics();
  void clear_has_graphics();
  void set_has_info();
  void clear_has_info();
  void set_has_installer();
  void clear_has_installer();
  void set_has_deployment();
  void clear_has_deployment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::buffers::resources::API* api_;
  ::buffers::resources::Compiler* compiler_;
  ::buffers::resources::General* general_;
  ::buffers::resources::Graphics* graphics_;
  ::buffers::resources::Info* info_;
  ::buffers::resources::Installer* installer_;
  ::buffers::resources::Deployment* deployment_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class API : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.API) */ {
 public:
  API();
  virtual ~API();

  API(const API& from);

  inline API& operator=(const API& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  API(API&& from) noexcept
    : API() {
    *this = ::std::move(from);
  }

  inline API& operator=(API&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const API& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const API* internal_default_instance() {
    return reinterpret_cast<const API*>(
               &_API_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(API* other);
  friend void swap(API& a, API& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline API* New() const final {
    return CreateMaybeMessage<API>(NULL);
  }

  API* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<API>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const API& from);
  void MergeFrom(const API& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(API* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string extensions = 8;
  int extensions_size() const;
  void clear_extensions();
  static const int kExtensionsFieldNumber = 8;
  const ::std::string& extensions(int index) const;
  ::std::string* mutable_extensions(int index);
  void set_extensions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_extensions(int index, ::std::string&& value);
  #endif
  void set_extensions(int index, const char* value);
  void set_extensions(int index, const char* value, size_t size);
  ::std::string* add_extensions();
  void add_extensions(const ::std::string& value);
  #if LANG_CXX11
  void add_extensions(::std::string&& value);
  #endif
  void add_extensions(const char* value);
  void add_extensions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& extensions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_extensions();

  // optional string target_audio = 1;
  bool has_target_audio() const;
  void clear_target_audio();
  static const int kTargetAudioFieldNumber = 1;
  const ::std::string& target_audio() const;
  void set_target_audio(const ::std::string& value);
  #if LANG_CXX11
  void set_target_audio(::std::string&& value);
  #endif
  void set_target_audio(const char* value);
  void set_target_audio(const char* value, size_t size);
  ::std::string* mutable_target_audio();
  ::std::string* release_target_audio();
  void set_allocated_target_audio(::std::string* target_audio);

  // optional string target_platform = 2;
  bool has_target_platform() const;
  void clear_target_platform();
  static const int kTargetPlatformFieldNumber = 2;
  const ::std::string& target_platform() const;
  void set_target_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_target_platform(::std::string&& value);
  #endif
  void set_target_platform(const char* value);
  void set_target_platform(const char* value, size_t size);
  ::std::string* mutable_target_platform();
  ::std::string* release_target_platform();
  void set_allocated_target_platform(::std::string* target_platform);

  // optional string target_compiler = 3;
  bool has_target_compiler() const;
  void clear_target_compiler();
  static const int kTargetCompilerFieldNumber = 3;
  const ::std::string& target_compiler() const;
  void set_target_compiler(const ::std::string& value);
  #if LANG_CXX11
  void set_target_compiler(::std::string&& value);
  #endif
  void set_target_compiler(const char* value);
  void set_target_compiler(const char* value, size_t size);
  ::std::string* mutable_target_compiler();
  ::std::string* release_target_compiler();
  void set_allocated_target_compiler(::std::string* target_compiler);

  // optional string target_graphics = 4;
  bool has_target_graphics() const;
  void clear_target_graphics();
  static const int kTargetGraphicsFieldNumber = 4;
  const ::std::string& target_graphics() const;
  void set_target_graphics(const ::std::string& value);
  #if LANG_CXX11
  void set_target_graphics(::std::string&& value);
  #endif
  void set_target_graphics(const char* value);
  void set_target_graphics(const char* value, size_t size);
  ::std::string* mutable_target_graphics();
  ::std::string* release_target_graphics();
  void set_allocated_target_graphics(::std::string* target_graphics);

  // optional string target_widgets = 5;
  bool has_target_widgets() const;
  void clear_target_widgets();
  static const int kTargetWidgetsFieldNumber = 5;
  const ::std::string& target_widgets() const;
  void set_target_widgets(const ::std::string& value);
  #if LANG_CXX11
  void set_target_widgets(::std::string&& value);
  #endif
  void set_target_widgets(const char* value);
  void set_target_widgets(const char* value, size_t size);
  ::std::string* mutable_target_widgets();
  ::std::string* release_target_widgets();
  void set_allocated_target_widgets(::std::string* target_widgets);

  // optional string target_collision = 6;
  bool has_target_collision() const;
  void clear_target_collision();
  static const int kTargetCollisionFieldNumber = 6;
  const ::std::string& target_collision() const;
  void set_target_collision(const ::std::string& value);
  #if LANG_CXX11
  void set_target_collision(::std::string&& value);
  #endif
  void set_target_collision(const char* value);
  void set_target_collision(const char* value, size_t size);
  ::std::string* mutable_target_collision();
  ::std::string* release_target_collision();
  void set_allocated_target_collision(::std::string* target_collision);

  // optional string target_network = 7;
  bool has_target_network() const;
  void clear_target_network();
  static const int kTargetNetworkFieldNumber = 7;
  const ::std::string& target_network() const;
  void set_target_network(const ::std::string& value);
  #if LANG_CXX11
  void set_target_network(::std::string&& value);
  #endif
  void set_target_network(const char* value);
  void set_target_network(const char* value, size_t size);
  ::std::string* mutable_target_network();
  ::std::string* release_target_network();
  void set_allocated_target_network(::std::string* target_network);

  // @@protoc_insertion_point(class_scope:buffers.resources.API)
 private:
  void set_has_target_audio();
  void clear_has_target_audio();
  void set_has_target_platform();
  void clear_has_target_platform();
  void set_has_target_compiler();
  void clear_has_target_compiler();
  void set_has_target_graphics();
  void clear_has_target_graphics();
  void set_has_target_widgets();
  void clear_has_target_widgets();
  void set_has_target_collision();
  void clear_has_target_collision();
  void set_has_target_network();
  void clear_has_target_network();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> extensions_;
  ::google::protobuf::internal::ArenaStringPtr target_audio_;
  ::google::protobuf::internal::ArenaStringPtr target_platform_;
  ::google::protobuf::internal::ArenaStringPtr target_compiler_;
  ::google::protobuf::internal::ArenaStringPtr target_graphics_;
  ::google::protobuf::internal::ArenaStringPtr target_widgets_;
  ::google::protobuf::internal::ArenaStringPtr target_collision_;
  ::google::protobuf::internal::ArenaStringPtr target_network_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Compiler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Compiler) */ {
 public:
  Compiler();
  virtual ~Compiler();

  Compiler(const Compiler& from);

  inline Compiler& operator=(const Compiler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Compiler(Compiler&& from) noexcept
    : Compiler() {
    *this = ::std::move(from);
  }

  inline Compiler& operator=(Compiler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Compiler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Compiler* internal_default_instance() {
    return reinterpret_cast<const Compiler*>(
               &_Compiler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Compiler* other);
  friend void swap(Compiler& a, Compiler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Compiler* New() const final {
    return CreateMaybeMessage<Compiler>(NULL);
  }

  Compiler* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Compiler>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Compiler& from);
  void MergeFrom(const Compiler& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compiler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keyword_blacklist = 8;
  int keyword_blacklist_size() const;
  void clear_keyword_blacklist();
  static const int kKeywordBlacklistFieldNumber = 8;
  const ::std::string& keyword_blacklist(int index) const;
  ::std::string* mutable_keyword_blacklist(int index);
  void set_keyword_blacklist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keyword_blacklist(int index, ::std::string&& value);
  #endif
  void set_keyword_blacklist(int index, const char* value);
  void set_keyword_blacklist(int index, const char* value, size_t size);
  ::std::string* add_keyword_blacklist();
  void add_keyword_blacklist(const ::std::string& value);
  #if LANG_CXX11
  void add_keyword_blacklist(::std::string&& value);
  #endif
  void add_keyword_blacklist(const char* value);
  void add_keyword_blacklist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keyword_blacklist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keyword_blacklist();

  // optional string eobjs_directory = 9;
  bool has_eobjs_directory() const;
  void clear_eobjs_directory();
  static const int kEobjsDirectoryFieldNumber = 9;
  const ::std::string& eobjs_directory() const;
  void set_eobjs_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_eobjs_directory(::std::string&& value);
  #endif
  void set_eobjs_directory(const char* value);
  void set_eobjs_directory(const char* value, size_t size);
  ::std::string* mutable_eobjs_directory();
  ::std::string* release_eobjs_directory();
  void set_allocated_eobjs_directory(::std::string* eobjs_directory);

  // optional string codegen_directory = 10;
  bool has_codegen_directory() const;
  void clear_codegen_directory();
  static const int kCodegenDirectoryFieldNumber = 10;
  const ::std::string& codegen_directory() const;
  void set_codegen_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_codegen_directory(::std::string&& value);
  #endif
  void set_codegen_directory(const char* value);
  void set_codegen_directory(const char* value, size_t size);
  ::std::string* mutable_codegen_directory();
  ::std::string* release_codegen_directory();
  void set_allocated_codegen_directory(::std::string* codegen_directory);

  // optional uint32 inherit_strings = 1;
  bool has_inherit_strings() const;
  void clear_inherit_strings();
  static const int kInheritStringsFieldNumber = 1;
  ::google::protobuf::uint32 inherit_strings() const;
  void set_inherit_strings(::google::protobuf::uint32 value);

  // optional uint32 inherit_escapes = 2;
  bool has_inherit_escapes() const;
  void clear_inherit_escapes();
  static const int kInheritEscapesFieldNumber = 2;
  ::google::protobuf::uint32 inherit_escapes() const;
  void set_inherit_escapes(::google::protobuf::uint32 value);

  // optional uint32 inherit_increment = 3;
  bool has_inherit_increment() const;
  void clear_inherit_increment();
  static const int kInheritIncrementFieldNumber = 3;
  ::google::protobuf::uint32 inherit_increment() const;
  void set_inherit_increment(::google::protobuf::uint32 value);

  // optional uint32 inherit_equivalence = 4;
  bool has_inherit_equivalence() const;
  void clear_inherit_equivalence();
  static const int kInheritEquivalenceFieldNumber = 4;
  ::google::protobuf::uint32 inherit_equivalence() const;
  void set_inherit_equivalence(::google::protobuf::uint32 value);

  // optional uint32 inherit_literals = 5;
  bool has_inherit_literals() const;
  void clear_inherit_literals();
  static const int kInheritLiteralsFieldNumber = 5;
  ::google::protobuf::uint32 inherit_literals() const;
  void set_inherit_literals(::google::protobuf::uint32 value);

  // optional uint32 inherit_negatives = 6;
  bool has_inherit_negatives() const;
  void clear_inherit_negatives();
  static const int kInheritNegativesFieldNumber = 6;
  ::google::protobuf::uint32 inherit_negatives() const;
  void set_inherit_negatives(::google::protobuf::uint32 value);

  // optional uint32 compliance_mode = 7;
  bool has_compliance_mode() const;
  void clear_compliance_mode();
  static const int kComplianceModeFieldNumber = 7;
  ::google::protobuf::uint32 compliance_mode() const;
  void set_compliance_mode(::google::protobuf::uint32 value);

  // optional bool inherit_objects = 11;
  bool has_inherit_objects() const;
  void clear_inherit_objects();
  static const int kInheritObjectsFieldNumber = 11;
  bool inherit_objects() const;
  void set_inherit_objects(bool value);

  // optional bool automatic_semicolons = 12;
  bool has_automatic_semicolons() const;
  void clear_automatic_semicolons();
  static const int kAutomaticSemicolonsFieldNumber = 12;
  bool automatic_semicolons() const;
  void set_automatic_semicolons(bool value);

  // optional uint32 graphics_angular_unit = 13;
  bool has_graphics_angular_unit() const;
  void clear_graphics_angular_unit();
  static const int kGraphicsAngularUnitFieldNumber = 13;
  ::google::protobuf::uint32 graphics_angular_unit() const;
  void set_graphics_angular_unit(::google::protobuf::uint32 value);

  // optional uint32 graphics_scalar_precision = 14;
  bool has_graphics_scalar_precision() const;
  void clear_graphics_scalar_precision();
  static const int kGraphicsScalarPrecisionFieldNumber = 14;
  ::google::protobuf::uint32 graphics_scalar_precision() const;
  void set_graphics_scalar_precision(::google::protobuf::uint32 value);

  // optional uint32 collision_angular_unit = 15;
  bool has_collision_angular_unit() const;
  void clear_collision_angular_unit();
  static const int kCollisionAngularUnitFieldNumber = 15;
  ::google::protobuf::uint32 collision_angular_unit() const;
  void set_collision_angular_unit(::google::protobuf::uint32 value);

  // optional uint32 collision_scalar_precision = 16;
  bool has_collision_scalar_precision() const;
  void clear_collision_scalar_precision();
  static const int kCollisionScalarPrecisionFieldNumber = 16;
  ::google::protobuf::uint32 collision_scalar_precision() const;
  void set_collision_scalar_precision(::google::protobuf::uint32 value);

  // optional uint32 audio_angular_unit = 17;
  bool has_audio_angular_unit() const;
  void clear_audio_angular_unit();
  static const int kAudioAngularUnitFieldNumber = 17;
  ::google::protobuf::uint32 audio_angular_unit() const;
  void set_audio_angular_unit(::google::protobuf::uint32 value);

  // optional uint32 audio_scalar_precision = 18;
  bool has_audio_scalar_precision() const;
  void clear_audio_scalar_precision();
  static const int kAudioScalarPrecisionFieldNumber = 18;
  ::google::protobuf::uint32 audio_scalar_precision() const;
  void set_audio_scalar_precision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Compiler)
 private:
  void set_has_inherit_strings();
  void clear_has_inherit_strings();
  void set_has_inherit_escapes();
  void clear_has_inherit_escapes();
  void set_has_inherit_increment();
  void clear_has_inherit_increment();
  void set_has_inherit_equivalence();
  void clear_has_inherit_equivalence();
  void set_has_inherit_literals();
  void clear_has_inherit_literals();
  void set_has_inherit_negatives();
  void clear_has_inherit_negatives();
  void set_has_compliance_mode();
  void clear_has_compliance_mode();
  void set_has_eobjs_directory();
  void clear_has_eobjs_directory();
  void set_has_codegen_directory();
  void clear_has_codegen_directory();
  void set_has_inherit_objects();
  void clear_has_inherit_objects();
  void set_has_automatic_semicolons();
  void clear_has_automatic_semicolons();
  void set_has_graphics_angular_unit();
  void clear_has_graphics_angular_unit();
  void set_has_graphics_scalar_precision();
  void clear_has_graphics_scalar_precision();
  void set_has_collision_angular_unit();
  void clear_has_collision_angular_unit();
  void set_has_collision_scalar_precision();
  void clear_has_collision_scalar_precision();
  void set_has_audio_angular_unit();
  void clear_has_audio_angular_unit();
  void set_has_audio_scalar_precision();
  void clear_has_audio_scalar_precision();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keyword_blacklist_;
  ::google::protobuf::internal::ArenaStringPtr eobjs_directory_;
  ::google::protobuf::internal::ArenaStringPtr codegen_directory_;
  ::google::protobuf::uint32 inherit_strings_;
  ::google::protobuf::uint32 inherit_escapes_;
  ::google::protobuf::uint32 inherit_increment_;
  ::google::protobuf::uint32 inherit_equivalence_;
  ::google::protobuf::uint32 inherit_literals_;
  ::google::protobuf::uint32 inherit_negatives_;
  ::google::protobuf::uint32 compliance_mode_;
  bool inherit_objects_;
  bool automatic_semicolons_;
  ::google::protobuf::uint32 graphics_angular_unit_;
  ::google::protobuf::uint32 graphics_scalar_precision_;
  ::google::protobuf::uint32 collision_angular_unit_;
  ::google::protobuf::uint32 collision_scalar_precision_;
  ::google::protobuf::uint32 audio_angular_unit_;
  ::google::protobuf::uint32 audio_scalar_precision_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class General : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.General) */ {
 public:
  General();
  virtual ~General();

  General(const General& from);

  inline General& operator=(const General& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  General(General&& from) noexcept
    : General() {
    *this = ::std::move(from);
  }

  inline General& operator=(General&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const General& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const General* internal_default_instance() {
    return reinterpret_cast<const General*>(
               &_General_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(General* other);
  friend void swap(General& a, General& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline General* New() const final {
    return CreateMaybeMessage<General>(NULL);
  }

  General* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<General>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const General& from);
  void MergeFrom(const General& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(General* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_guid = 2 [(.buffers.gmx) = "option_gameguid"];
  bool has_game_guid() const;
  void clear_game_guid();
  static const int kGameGuidFieldNumber = 2;
  const ::std::string& game_guid() const;
  void set_game_guid(const ::std::string& value);
  #if LANG_CXX11
  void set_game_guid(::std::string&& value);
  #endif
  void set_game_guid(const char* value);
  void set_game_guid(const char* value, size_t size);
  ::std::string* mutable_game_guid();
  ::std::string* release_game_guid();
  void set_allocated_game_guid(::std::string* game_guid);

  // optional string display_name = 4 [(.buffers.gmx) = "option_display_name"];
  bool has_display_name() const;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // optional string company = 9 [(.buffers.gmx) = "option_version_company"];
  bool has_company() const;
  void clear_company();
  static const int kCompanyFieldNumber = 9;
  const ::std::string& company() const;
  void set_company(const ::std::string& value);
  #if LANG_CXX11
  void set_company(::std::string&& value);
  #endif
  void set_company(const char* value);
  void set_company(const char* value, size_t size);
  ::std::string* mutable_company();
  ::std::string* release_company();
  void set_allocated_company(::std::string* company);

  // optional string product = 10 [(.buffers.gmx) = "option_version_product"];
  bool has_product() const;
  void clear_product();
  static const int kProductFieldNumber = 10;
  const ::std::string& product() const;
  void set_product(const ::std::string& value);
  #if LANG_CXX11
  void set_product(::std::string&& value);
  #endif
  void set_product(const char* value);
  void set_product(const char* value, size_t size);
  ::std::string* mutable_product();
  ::std::string* release_product();
  void set_allocated_product(::std::string* product);

  // optional string copyright = 11 [(.buffers.gmx) = "option_version_copyright"];
  bool has_copyright() const;
  void clear_copyright();
  static const int kCopyrightFieldNumber = 11;
  const ::std::string& copyright() const;
  void set_copyright(const ::std::string& value);
  #if LANG_CXX11
  void set_copyright(::std::string&& value);
  #endif
  void set_copyright(const char* value);
  void set_copyright(const char* value, size_t size);
  ::std::string* mutable_copyright();
  ::std::string* release_copyright();
  void set_allocated_copyright(::std::string* copyright);

  // optional string description = 12 [(.buffers.gmx) = "option_version_description"];
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 12;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string game_icon = 14 [(.buffers.gmx) = "option_windows_game_icon"];
  bool has_game_icon() const;
  void clear_game_icon();
  static const int kGameIconFieldNumber = 14;
  const ::std::string& game_icon() const;
  void set_game_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_game_icon(::std::string&& value);
  #endif
  void set_game_icon(const char* value);
  void set_game_icon(const char* value, size_t size);
  ::std::string* mutable_game_icon();
  ::std::string* release_game_icon();
  void set_allocated_game_icon(::std::string* game_icon);

  // optional string splash_screen = 15 [(.buffers.gmx) = "option_windows_splash_screen"];
  bool has_splash_screen() const;
  void clear_splash_screen();
  static const int kSplashScreenFieldNumber = 15;
  const ::std::string& splash_screen() const;
  void set_splash_screen(const ::std::string& value);
  #if LANG_CXX11
  void set_splash_screen(::std::string&& value);
  #endif
  void set_splash_screen(const char* value);
  void set_splash_screen(const char* value, size_t size);
  ::std::string* mutable_splash_screen();
  ::std::string* release_splash_screen();
  void set_allocated_splash_screen(::std::string* splash_screen);

  // optional string save_data_location = 18 [(.buffers.gmx) = "option_windows_save_location"];
  bool has_save_data_location() const;
  void clear_save_data_location();
  static const int kSaveDataLocationFieldNumber = 18;
  const ::std::string& save_data_location() const;
  void set_save_data_location(const ::std::string& value);
  #if LANG_CXX11
  void set_save_data_location(::std::string&& value);
  #endif
  void set_save_data_location(const char* value);
  void set_save_data_location(const char* value, size_t size);
  ::std::string* mutable_save_data_location();
  ::std::string* release_save_data_location();
  void set_allocated_save_data_location(::std::string* save_data_location);

  // optional uint64 game_id = 1 [(.buffers.gmx) = "option_gameid"];
  bool has_game_id() const;
  void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint64 game_id() const;
  void set_game_id(::google::protobuf::uint64 value);

  // optional int32 color_outside_room_region = 3 [(.buffers.gmx) = "option_windowcolor"];
  bool has_color_outside_room_region() const;
  void clear_color_outside_room_region();
  static const int kColorOutsideRoomRegionFieldNumber = 3;
  ::google::protobuf::int32 color_outside_room_region() const;
  void set_color_outside_room_region(::google::protobuf::int32 value);

  // optional uint32 version_major = 5 [(.buffers.gmx) = "option_version_major"];
  bool has_version_major() const;
  void clear_version_major();
  static const int kVersionMajorFieldNumber = 5;
  ::google::protobuf::uint32 version_major() const;
  void set_version_major(::google::protobuf::uint32 value);

  // optional uint32 version_minor = 6 [(.buffers.gmx) = "option_version_minor"];
  bool has_version_minor() const;
  void clear_version_minor();
  static const int kVersionMinorFieldNumber = 6;
  ::google::protobuf::uint32 version_minor() const;
  void set_version_minor(::google::protobuf::uint32 value);

  // optional uint32 version_release = 7 [(.buffers.gmx) = "option_version_release"];
  bool has_version_release() const;
  void clear_version_release();
  static const int kVersionReleaseFieldNumber = 7;
  ::google::protobuf::uint32 version_release() const;
  void set_version_release(::google::protobuf::uint32 value);

  // optional uint32 version_build = 8 [(.buffers.gmx) = "option_version_build"];
  bool has_version_build() const;
  void clear_version_build();
  static const int kVersionBuildFieldNumber = 8;
  ::google::protobuf::uint32 version_build() const;
  void set_version_build(::google::protobuf::uint32 value);

  // optional bool show_cursor = 13 [(.buffers.gmx) = "option_showcursor"];
  bool has_show_cursor() const;
  void clear_show_cursor();
  static const int kShowCursorFieldNumber = 13;
  bool show_cursor() const;
  void set_show_cursor(bool value);

  // optional bool show_splash_screen = 16 [(.buffers.gmx) = "option_windows_use_splash"];
  bool has_show_splash_screen() const;
  void clear_show_splash_screen();
  static const int kShowSplashScreenFieldNumber = 16;
  bool show_splash_screen() const;
  void set_show_splash_screen(bool value);

  // optional bool menu_dock = 19 [(.buffers.gmx) = "option_mac_menu_dock"];
  bool has_menu_dock() const;
  void clear_menu_dock();
  static const int kMenuDockFieldNumber = 19;
  bool menu_dock() const;
  void set_menu_dock(bool value);

  // optional uint32 sleep_margin = 17 [(.buffers.gmx) = "option_windows_sleep_margin"];
  bool has_sleep_margin() const;
  void clear_sleep_margin();
  static const int kSleepMarginFieldNumber = 17;
  ::google::protobuf::uint32 sleep_margin() const;
  void set_sleep_margin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.General)
 private:
  void set_has_game_id();
  void clear_has_game_id();
  void set_has_game_guid();
  void clear_has_game_guid();
  void set_has_color_outside_room_region();
  void clear_has_color_outside_room_region();
  void set_has_display_name();
  void clear_has_display_name();
  void set_has_version_major();
  void clear_has_version_major();
  void set_has_version_minor();
  void clear_has_version_minor();
  void set_has_version_release();
  void clear_has_version_release();
  void set_has_version_build();
  void clear_has_version_build();
  void set_has_company();
  void clear_has_company();
  void set_has_product();
  void clear_has_product();
  void set_has_copyright();
  void clear_has_copyright();
  void set_has_description();
  void clear_has_description();
  void set_has_show_cursor();
  void clear_has_show_cursor();
  void set_has_game_icon();
  void clear_has_game_icon();
  void set_has_splash_screen();
  void clear_has_splash_screen();
  void set_has_show_splash_screen();
  void clear_has_show_splash_screen();
  void set_has_sleep_margin();
  void clear_has_sleep_margin();
  void set_has_save_data_location();
  void clear_has_save_data_location();
  void set_has_menu_dock();
  void clear_has_menu_dock();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_guid_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr company_;
  ::google::protobuf::internal::ArenaStringPtr product_;
  ::google::protobuf::internal::ArenaStringPtr copyright_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr game_icon_;
  ::google::protobuf::internal::ArenaStringPtr splash_screen_;
  ::google::protobuf::internal::ArenaStringPtr save_data_location_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::int32 color_outside_room_region_;
  ::google::protobuf::uint32 version_major_;
  ::google::protobuf::uint32 version_minor_;
  ::google::protobuf::uint32 version_release_;
  ::google::protobuf::uint32 version_build_;
  bool show_cursor_;
  bool show_splash_screen_;
  bool menu_dock_;
  ::google::protobuf::uint32 sleep_margin_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Graphics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Graphics) */ {
 public:
  Graphics();
  virtual ~Graphics();

  Graphics(const Graphics& from);

  inline Graphics& operator=(const Graphics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Graphics(Graphics&& from) noexcept
    : Graphics() {
    *this = ::std::move(from);
  }

  inline Graphics& operator=(Graphics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graphics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Graphics* internal_default_instance() {
    return reinterpret_cast<const Graphics*>(
               &_Graphics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Graphics* other);
  friend void swap(Graphics& a, Graphics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Graphics* New() const final {
    return CreateMaybeMessage<Graphics>(NULL);
  }

  Graphics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Graphics>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Graphics& from);
  void MergeFrom(const Graphics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graphics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Graphics_VertexBufferMethod VertexBufferMethod;
  static const VertexBufferMethod FAST =
    Graphics_VertexBufferMethod_FAST;
  static const VertexBufferMethod COMPATIBLE =
    Graphics_VertexBufferMethod_COMPATIBLE;
  static const VertexBufferMethod MOST_COMPATIBLE =
    Graphics_VertexBufferMethod_MOST_COMPATIBLE;
  static inline bool VertexBufferMethod_IsValid(int value) {
    return Graphics_VertexBufferMethod_IsValid(value);
  }
  static const VertexBufferMethod VertexBufferMethod_MIN =
    Graphics_VertexBufferMethod_VertexBufferMethod_MIN;
  static const VertexBufferMethod VertexBufferMethod_MAX =
    Graphics_VertexBufferMethod_VertexBufferMethod_MAX;
  static const int VertexBufferMethod_ARRAYSIZE =
    Graphics_VertexBufferMethod_VertexBufferMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VertexBufferMethod_descriptor() {
    return Graphics_VertexBufferMethod_descriptor();
  }
  static inline const ::std::string& VertexBufferMethod_Name(VertexBufferMethod value) {
    return Graphics_VertexBufferMethod_Name(value);
  }
  static inline bool VertexBufferMethod_Parse(const ::std::string& name,
      VertexBufferMethod* value) {
    return Graphics_VertexBufferMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool start_in_fullscreen = 1 [(.buffers.gmx) = "option_fullscreen"];
  bool has_start_in_fullscreen() const;
  void clear_start_in_fullscreen();
  static const int kStartInFullscreenFieldNumber = 1;
  bool start_in_fullscreen() const;
  void set_start_in_fullscreen(bool value);

  // optional bool allow_fullscreen_change = 2 [(.buffers.gmx) = "option_screenkey"];
  bool has_allow_fullscreen_change() const;
  void clear_allow_fullscreen_change();
  static const int kAllowFullscreenChangeFieldNumber = 2;
  bool allow_fullscreen_change() const;
  void set_allow_fullscreen_change(bool value);

  // optional bool smooth_colors = 3 [(.buffers.gmx) = "option_interpolate"];
  bool has_smooth_colors() const;
  void clear_smooth_colors();
  static const int kSmoothColorsFieldNumber = 3;
  bool smooth_colors() const;
  void set_smooth_colors(bool value);

  // optional bool force_software_vertex_processing = 4 [(.buffers.gmx) = ""];
  bool has_force_software_vertex_processing() const;
  void clear_force_software_vertex_processing();
  static const int kForceSoftwareVertexProcessingFieldNumber = 4;
  bool force_software_vertex_processing() const;
  void set_force_software_vertex_processing(bool value);

  // optional bool freeze_on_lose_focus = 5 [(.buffers.gmx) = "option_freeze"];
  bool has_freeze_on_lose_focus() const;
  void clear_freeze_on_lose_focus();
  static const int kFreezeOnLoseFocusFieldNumber = 5;
  bool freeze_on_lose_focus() const;
  void set_freeze_on_lose_focus(bool value);

  // optional bool use_synchronization = 6 [(.buffers.gmx) = ""];
  bool has_use_synchronization() const;
  void clear_use_synchronization();
  static const int kUseSynchronizationFieldNumber = 6;
  bool use_synchronization() const;
  void set_use_synchronization(bool value);

  // optional bool window_sizeable = 7 [(.buffers.gmx) = "option_sizeable"];
  bool has_window_sizeable() const;
  void clear_window_sizeable();
  static const int kWindowSizeableFieldNumber = 7;
  bool window_sizeable() const;
  void set_window_sizeable(bool value);

  // optional bool window_showborder = 8 [(.buffers.gmx) = "option_noborder"];
  bool has_window_showborder() const;
  void clear_window_showborder();
  static const int kWindowShowborderFieldNumber = 8;
  bool window_showborder() const;
  void set_window_showborder(bool value);

  // optional double window_scale = 11 [(.buffers.gmx) = "option_scale"];
  bool has_window_scale() const;
  void clear_window_scale();
  static const int kWindowScaleFieldNumber = 11;
  double window_scale() const;
  void set_window_scale(double value);

  // optional bool window_showicons = 9 [(.buffers.gmx) = "option_nobuttons"];
  bool has_window_showicons() const;
  void clear_window_showicons();
  static const int kWindowShowiconsFieldNumber = 9;
  bool window_showicons() const;
  void set_window_showicons(bool value);

  // optional bool window_stayontop = 10 [(.buffers.gmx) = "option_stayontop"];
  bool has_window_stayontop() const;
  void clear_window_stayontop();
  static const int kWindowStayontopFieldNumber = 10;
  bool window_stayontop() const;
  void set_window_stayontop(bool value);

  // optional bool create_textures_on_demand = 12 [(.buffers.gmx) = "option_windows_create_textures_on_demand"];
  bool has_create_textures_on_demand() const;
  void clear_create_textures_on_demand();
  static const int kCreateTexturesOnDemandFieldNumber = 12;
  bool create_textures_on_demand() const;
  void set_create_textures_on_demand(bool value);

  // optional bool alternate_synchronization_method = 13 [(.buffers.gmx) = "option_windows_alternate_sync_method"];
  bool has_alternate_synchronization_method() const;
  void clear_alternate_synchronization_method();
  static const int kAlternateSynchronizationMethodFieldNumber = 13;
  bool alternate_synchronization_method() const;
  void set_alternate_synchronization_method(bool value);

  // optional .buffers.resources.Graphics.VertexBufferMethod vertex_buffer_method = 14 [(.buffers.gmx) = "option_windows_vertex_buffer_method2"];
  bool has_vertex_buffer_method() const;
  void clear_vertex_buffer_method();
  static const int kVertexBufferMethodFieldNumber = 14;
  ::buffers::resources::Graphics_VertexBufferMethod vertex_buffer_method() const;
  void set_vertex_buffer_method(::buffers::resources::Graphics_VertexBufferMethod value);

  // optional uint32 texture_page_size = 15 [(.buffers.gmx) = "option_windows_texture_page"];
  bool has_texture_page_size() const;
  void clear_texture_page_size();
  static const int kTexturePageSizeFieldNumber = 15;
  ::google::protobuf::uint32 texture_page_size() const;
  void set_texture_page_size(::google::protobuf::uint32 value);

  // optional bool enable_hidpi = 16 [(.buffers.gmx) = "option_mac_enable_retina"];
  bool has_enable_hidpi() const;
  void clear_enable_hidpi();
  static const int kEnableHidpiFieldNumber = 16;
  bool enable_hidpi() const;
  void set_enable_hidpi(bool value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Graphics)
 private:
  void set_has_start_in_fullscreen();
  void clear_has_start_in_fullscreen();
  void set_has_allow_fullscreen_change();
  void clear_has_allow_fullscreen_change();
  void set_has_smooth_colors();
  void clear_has_smooth_colors();
  void set_has_force_software_vertex_processing();
  void clear_has_force_software_vertex_processing();
  void set_has_freeze_on_lose_focus();
  void clear_has_freeze_on_lose_focus();
  void set_has_use_synchronization();
  void clear_has_use_synchronization();
  void set_has_window_sizeable();
  void clear_has_window_sizeable();
  void set_has_window_showborder();
  void clear_has_window_showborder();
  void set_has_window_showicons();
  void clear_has_window_showicons();
  void set_has_window_stayontop();
  void clear_has_window_stayontop();
  void set_has_window_scale();
  void clear_has_window_scale();
  void set_has_create_textures_on_demand();
  void clear_has_create_textures_on_demand();
  void set_has_alternate_synchronization_method();
  void clear_has_alternate_synchronization_method();
  void set_has_vertex_buffer_method();
  void clear_has_vertex_buffer_method();
  void set_has_texture_page_size();
  void clear_has_texture_page_size();
  void set_has_enable_hidpi();
  void clear_has_enable_hidpi();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool start_in_fullscreen_;
  bool allow_fullscreen_change_;
  bool smooth_colors_;
  bool force_software_vertex_processing_;
  bool freeze_on_lose_focus_;
  bool use_synchronization_;
  bool window_sizeable_;
  bool window_showborder_;
  double window_scale_;
  bool window_showicons_;
  bool window_stayontop_;
  bool create_textures_on_demand_;
  bool alternate_synchronization_method_;
  int vertex_buffer_method_;
  ::google::protobuf::uint32 texture_page_size_;
  bool enable_hidpi_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Info) */ {
 public:
  Info();
  virtual ~Info();

  Info(const Info& from);

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Info* other);
  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Info* New() const final {
    return CreateMaybeMessage<Info>(NULL);
  }

  Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string author_name = 1 [(.buffers.gmx) = "option_author"];
  bool has_author_name() const;
  void clear_author_name();
  static const int kAuthorNameFieldNumber = 1;
  const ::std::string& author_name() const;
  void set_author_name(const ::std::string& value);
  #if LANG_CXX11
  void set_author_name(::std::string&& value);
  #endif
  void set_author_name(const char* value);
  void set_author_name(const char* value, size_t size);
  ::std::string* mutable_author_name();
  ::std::string* release_author_name();
  void set_allocated_author_name(::std::string* author_name);

  // optional string author_email = 2 [(.buffers.gmx) = "option_linux_maintainer_email"];
  bool has_author_email() const;
  void clear_author_email();
  static const int kAuthorEmailFieldNumber = 2;
  const ::std::string& author_email() const;
  void set_author_email(const ::std::string& value);
  #if LANG_CXX11
  void set_author_email(::std::string&& value);
  #endif
  void set_author_email(const char* value);
  void set_author_email(const char* value, size_t size);
  ::std::string* mutable_author_email();
  ::std::string* release_author_email();
  void set_allocated_author_email(::std::string* author_email);

  // optional string website = 3 [(.buffers.gmx) = "option_linux_homepage"];
  bool has_website() const;
  void clear_website();
  static const int kWebsiteFieldNumber = 3;
  const ::std::string& website() const;
  void set_website(const ::std::string& value);
  #if LANG_CXX11
  void set_website(::std::string&& value);
  #endif
  void set_website(const char* value);
  void set_website(const char* value, size_t size);
  ::std::string* mutable_website();
  ::std::string* release_website();
  void set_allocated_website(::std::string* website);

  // optional string version = 4 [(.buffers.gmx) = "option_version"];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string information = 6 [(.buffers.gmx) = "option_information"];
  bool has_information() const;
  void clear_information();
  static const int kInformationFieldNumber = 6;
  const ::std::string& information() const;
  void set_information(const ::std::string& value);
  #if LANG_CXX11
  void set_information(::std::string&& value);
  #endif
  void set_information(const char* value);
  void set_information(const char* value, size_t size);
  ::std::string* mutable_information();
  ::std::string* release_information();
  void set_allocated_information(::std::string* information);

  // optional uint32 last_changed = 5 [(.buffers.gmx) = "option_lastchanged"];
  bool has_last_changed() const;
  void clear_last_changed();
  static const int kLastChangedFieldNumber = 5;
  ::google::protobuf::uint32 last_changed() const;
  void set_last_changed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Info)
 private:
  void set_has_author_name();
  void clear_has_author_name();
  void set_has_author_email();
  void clear_has_author_email();
  void set_has_website();
  void clear_has_website();
  void set_has_version();
  void clear_has_version();
  void set_has_last_changed();
  void clear_has_last_changed();
  void set_has_information();
  void clear_has_information();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr author_name_;
  ::google::protobuf::internal::ArenaStringPtr author_email_;
  ::google::protobuf::internal::ArenaStringPtr website_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr information_;
  ::google::protobuf::uint32 last_changed_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Installer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Installer) */ {
 public:
  Installer();
  virtual ~Installer();

  Installer(const Installer& from);

  inline Installer& operator=(const Installer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Installer(Installer&& from) noexcept
    : Installer() {
    *this = ::std::move(from);
  }

  inline Installer& operator=(Installer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Installer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Installer* internal_default_instance() {
    return reinterpret_cast<const Installer*>(
               &_Installer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Installer* other);
  friend void swap(Installer& a, Installer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Installer* New() const final {
    return CreateMaybeMessage<Installer>(NULL);
  }

  Installer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Installer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Installer& from);
  void MergeFrom(const Installer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Installer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string finished_image = 1 [(.buffers.gmx) = "option_windows_runner_finished"];
  bool has_finished_image() const;
  void clear_finished_image();
  static const int kFinishedImageFieldNumber = 1;
  const ::std::string& finished_image() const;
  void set_finished_image(const ::std::string& value);
  #if LANG_CXX11
  void set_finished_image(::std::string&& value);
  #endif
  void set_finished_image(const char* value);
  void set_finished_image(const char* value, size_t size);
  ::std::string* mutable_finished_image();
  ::std::string* release_finished_image();
  void set_allocated_finished_image(::std::string* finished_image);

  // optional string header_image = 2 [(.buffers.gmx) = "option_windows_runner_header"];
  bool has_header_image() const;
  void clear_header_image();
  static const int kHeaderImageFieldNumber = 2;
  const ::std::string& header_image() const;
  void set_header_image(const ::std::string& value);
  #if LANG_CXX11
  void set_header_image(::std::string&& value);
  #endif
  void set_header_image(const char* value);
  void set_header_image(const char* value, size_t size);
  ::std::string* mutable_header_image();
  ::std::string* release_header_image();
  void set_allocated_header_image(::std::string* header_image);

  // optional string script = 3 [(.buffers.gmx) = "option_windows_nsis_file"];
  bool has_script() const;
  void clear_script();
  static const int kScriptFieldNumber = 3;
  const ::std::string& script() const;
  void set_script(const ::std::string& value);
  #if LANG_CXX11
  void set_script(::std::string&& value);
  #endif
  void set_script(const char* value);
  void set_script(const char* value, size_t size);
  ::std::string* mutable_script();
  ::std::string* release_script();
  void set_allocated_script(::std::string* script);

  // optional string license_agreement = 4 [(.buffers.gmx) = "option_windows_license"];
  bool has_license_agreement() const;
  void clear_license_agreement();
  static const int kLicenseAgreementFieldNumber = 4;
  const ::std::string& license_agreement() const;
  void set_license_agreement(const ::std::string& value);
  #if LANG_CXX11
  void set_license_agreement(::std::string&& value);
  #endif
  void set_license_agreement(const char* value);
  void set_license_agreement(const char* value, size_t size);
  ::std::string* mutable_license_agreement();
  ::std::string* release_license_agreement();
  void set_allocated_license_agreement(::std::string* license_agreement);

  // @@protoc_insertion_point(class_scope:buffers.resources.Installer)
 private:
  void set_has_finished_image();
  void clear_has_finished_image();
  void set_has_header_image();
  void clear_has_header_image();
  void set_has_script();
  void clear_has_script();
  void set_has_license_agreement();
  void clear_has_license_agreement();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr finished_image_;
  ::google::protobuf::internal::ArenaStringPtr header_image_;
  ::google::protobuf::internal::ArenaStringPtr script_;
  ::google::protobuf::internal::ArenaStringPtr license_agreement_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Deployment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Deployment) */ {
 public:
  Deployment();
  virtual ~Deployment();

  Deployment(const Deployment& from);

  inline Deployment& operator=(const Deployment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Deployment(Deployment&& from) noexcept
    : Deployment() {
    *this = ::std::move(from);
  }

  inline Deployment& operator=(Deployment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Deployment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Deployment* internal_default_instance() {
    return reinterpret_cast<const Deployment*>(
               &_Deployment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Deployment* other);
  friend void swap(Deployment& a, Deployment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Deployment* New() const final {
    return CreateMaybeMessage<Deployment>(NULL);
  }

  Deployment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Deployment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Deployment& from);
  void MergeFrom(const Deployment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deployment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app_id = 1 [(.buffers.gmx) = "option_mac_app_id"];
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  const ::std::string& app_id() const;
  void set_app_id(const ::std::string& value);
  #if LANG_CXX11
  void set_app_id(::std::string&& value);
  #endif
  void set_app_id(const char* value);
  void set_app_id(const char* value, size_t size);
  ::std::string* mutable_app_id();
  ::std::string* release_app_id();
  void set_allocated_app_id(::std::string* app_id);

  // optional string app_output = 2 [(.buffers.gmx) = "option_mac_output_dir"];
  bool has_app_output() const;
  void clear_app_output();
  static const int kAppOutputFieldNumber = 2;
  const ::std::string& app_output() const;
  void set_app_output(const ::std::string& value);
  #if LANG_CXX11
  void set_app_output(::std::string&& value);
  #endif
  void set_app_output(const char* value);
  void set_app_output(const char* value, size_t size);
  ::std::string* mutable_app_output();
  ::std::string* release_app_output();
  void set_allocated_app_output(::std::string* app_output);

  // optional string team_identifier = 3 [(.buffers.gmx) = "option_mac_team_id"];
  bool has_team_identifier() const;
  void clear_team_identifier();
  static const int kTeamIdentifierFieldNumber = 3;
  const ::std::string& team_identifier() const;
  void set_team_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_team_identifier(::std::string&& value);
  #endif
  void set_team_identifier(const char* value);
  void set_team_identifier(const char* value, size_t size);
  ::std::string* mutable_team_identifier();
  ::std::string* release_team_identifier();
  void set_allocated_team_identifier(::std::string* team_identifier);

  // optional string app_category = 7 [(.buffers.gmx) = "option_mac_app_category"];
  bool has_app_category() const;
  void clear_app_category();
  static const int kAppCategoryFieldNumber = 7;
  const ::std::string& app_category() const;
  void set_app_category(const ::std::string& value);
  #if LANG_CXX11
  void set_app_category(::std::string&& value);
  #endif
  void set_app_category(const char* value);
  void set_app_category(const char* value, size_t size);
  ::std::string* mutable_app_category();
  ::std::string* release_app_category();
  void set_allocated_app_category(::std::string* app_category);

  // optional string signing_identity = 8 [(.buffers.gmx) = "option_mac_signing_identity"];
  bool has_signing_identity() const;
  void clear_signing_identity();
  static const int kSigningIdentityFieldNumber = 8;
  const ::std::string& signing_identity() const;
  void set_signing_identity(const ::std::string& value);
  #if LANG_CXX11
  void set_signing_identity(::std::string&& value);
  #endif
  void set_signing_identity(const char* value);
  void set_signing_identity(const char* value, size_t size);
  ::std::string* mutable_signing_identity();
  ::std::string* release_signing_identity();
  void set_allocated_signing_identity(::std::string* signing_identity);

  // optional bool enable_appstore_build = 4 [(.buffers.gmx) = "option_mac_create_app_store"];
  bool has_enable_appstore_build() const;
  void clear_enable_appstore_build();
  static const int kEnableAppstoreBuildFieldNumber = 4;
  bool enable_appstore_build() const;
  void set_enable_appstore_build(bool value);

  // optional bool allow_incoming_connections = 5 [(.buffers.gmx) = "option_mac_appstore_incoming_allow"];
  bool has_allow_incoming_connections() const;
  void clear_allow_incoming_connections();
  static const int kAllowIncomingConnectionsFieldNumber = 5;
  bool allow_incoming_connections() const;
  void set_allow_incoming_connections(bool value);

  // optional bool allow_outgoing_connections = 6 [(.buffers.gmx) = "option_mac_appstore_outgoing_allow"];
  bool has_allow_outgoing_connections() const;
  void clear_allow_outgoing_connections();
  static const int kAllowOutgoingConnectionsFieldNumber = 6;
  bool allow_outgoing_connections() const;
  void set_allow_outgoing_connections(bool value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Deployment)
 private:
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_app_output();
  void clear_has_app_output();
  void set_has_team_identifier();
  void clear_has_team_identifier();
  void set_has_enable_appstore_build();
  void clear_has_enable_appstore_build();
  void set_has_allow_incoming_connections();
  void clear_has_allow_incoming_connections();
  void set_has_allow_outgoing_connections();
  void clear_has_allow_outgoing_connections();
  void set_has_app_category();
  void clear_has_app_category();
  void set_has_signing_identity();
  void clear_has_signing_identity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr app_id_;
  ::google::protobuf::internal::ArenaStringPtr app_output_;
  ::google::protobuf::internal::ArenaStringPtr team_identifier_;
  ::google::protobuf::internal::ArenaStringPtr app_category_;
  ::google::protobuf::internal::ArenaStringPtr signing_identity_;
  bool enable_appstore_build_;
  bool allow_incoming_connections_;
  bool allow_outgoing_connections_;
  friend struct ::protobuf_Settings_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Settings

// optional .buffers.resources.API api = 1;
inline bool Settings::has_api() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Settings::set_has_api() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Settings::clear_has_api() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Settings::clear_api() {
  if (api_ != NULL) api_->Clear();
  clear_has_api();
}
inline const ::buffers::resources::API& Settings::_internal_api() const {
  return *api_;
}
inline const ::buffers::resources::API& Settings::api() const {
  const ::buffers::resources::API* p = api_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.api)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::API*>(
      &::buffers::resources::_API_default_instance_);
}
inline ::buffers::resources::API* Settings::release_api() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.api)
  clear_has_api();
  ::buffers::resources::API* temp = api_;
  api_ = NULL;
  return temp;
}
inline ::buffers::resources::API* Settings::mutable_api() {
  set_has_api();
  if (api_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::API>(GetArenaNoVirtual());
    api_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.api)
  return api_;
}
inline void Settings::set_allocated_api(::buffers::resources::API* api) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete api_;
  }
  if (api) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      api = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, api, submessage_arena);
    }
    set_has_api();
  } else {
    clear_has_api();
  }
  api_ = api;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.api)
}

// optional .buffers.resources.Compiler compiler = 2;
inline bool Settings::has_compiler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Settings::set_has_compiler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Settings::clear_has_compiler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Settings::clear_compiler() {
  if (compiler_ != NULL) compiler_->Clear();
  clear_has_compiler();
}
inline const ::buffers::resources::Compiler& Settings::_internal_compiler() const {
  return *compiler_;
}
inline const ::buffers::resources::Compiler& Settings::compiler() const {
  const ::buffers::resources::Compiler* p = compiler_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.compiler)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Compiler*>(
      &::buffers::resources::_Compiler_default_instance_);
}
inline ::buffers::resources::Compiler* Settings::release_compiler() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.compiler)
  clear_has_compiler();
  ::buffers::resources::Compiler* temp = compiler_;
  compiler_ = NULL;
  return temp;
}
inline ::buffers::resources::Compiler* Settings::mutable_compiler() {
  set_has_compiler();
  if (compiler_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Compiler>(GetArenaNoVirtual());
    compiler_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.compiler)
  return compiler_;
}
inline void Settings::set_allocated_compiler(::buffers::resources::Compiler* compiler) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete compiler_;
  }
  if (compiler) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      compiler = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, compiler, submessage_arena);
    }
    set_has_compiler();
  } else {
    clear_has_compiler();
  }
  compiler_ = compiler;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.compiler)
}

// optional .buffers.resources.General general = 3;
inline bool Settings::has_general() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Settings::set_has_general() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Settings::clear_has_general() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Settings::clear_general() {
  if (general_ != NULL) general_->Clear();
  clear_has_general();
}
inline const ::buffers::resources::General& Settings::_internal_general() const {
  return *general_;
}
inline const ::buffers::resources::General& Settings::general() const {
  const ::buffers::resources::General* p = general_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.general)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::General*>(
      &::buffers::resources::_General_default_instance_);
}
inline ::buffers::resources::General* Settings::release_general() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.general)
  clear_has_general();
  ::buffers::resources::General* temp = general_;
  general_ = NULL;
  return temp;
}
inline ::buffers::resources::General* Settings::mutable_general() {
  set_has_general();
  if (general_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::General>(GetArenaNoVirtual());
    general_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.general)
  return general_;
}
inline void Settings::set_allocated_general(::buffers::resources::General* general) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete general_;
  }
  if (general) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      general = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, general, submessage_arena);
    }
    set_has_general();
  } else {
    clear_has_general();
  }
  general_ = general;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.general)
}

// optional .buffers.resources.Graphics graphics = 4;
inline bool Settings::has_graphics() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Settings::set_has_graphics() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Settings::clear_has_graphics() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Settings::clear_graphics() {
  if (graphics_ != NULL) graphics_->Clear();
  clear_has_graphics();
}
inline const ::buffers::resources::Graphics& Settings::_internal_graphics() const {
  return *graphics_;
}
inline const ::buffers::resources::Graphics& Settings::graphics() const {
  const ::buffers::resources::Graphics* p = graphics_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.graphics)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Graphics*>(
      &::buffers::resources::_Graphics_default_instance_);
}
inline ::buffers::resources::Graphics* Settings::release_graphics() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.graphics)
  clear_has_graphics();
  ::buffers::resources::Graphics* temp = graphics_;
  graphics_ = NULL;
  return temp;
}
inline ::buffers::resources::Graphics* Settings::mutable_graphics() {
  set_has_graphics();
  if (graphics_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Graphics>(GetArenaNoVirtual());
    graphics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.graphics)
  return graphics_;
}
inline void Settings::set_allocated_graphics(::buffers::resources::Graphics* graphics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete graphics_;
  }
  if (graphics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      graphics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graphics, submessage_arena);
    }
    set_has_graphics();
  } else {
    clear_has_graphics();
  }
  graphics_ = graphics;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.graphics)
}

// optional .buffers.resources.Info info = 5;
inline bool Settings::has_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Settings::set_has_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Settings::clear_has_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Settings::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::buffers::resources::Info& Settings::_internal_info() const {
  return *info_;
}
inline const ::buffers::resources::Info& Settings::info() const {
  const ::buffers::resources::Info* p = info_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.info)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Info*>(
      &::buffers::resources::_Info_default_instance_);
}
inline ::buffers::resources::Info* Settings::release_info() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.info)
  clear_has_info();
  ::buffers::resources::Info* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::buffers::resources::Info* Settings::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Info>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.info)
  return info_;
}
inline void Settings::set_allocated_info(::buffers::resources::Info* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.info)
}

// optional .buffers.resources.Installer installer = 6;
inline bool Settings::has_installer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Settings::set_has_installer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Settings::clear_has_installer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Settings::clear_installer() {
  if (installer_ != NULL) installer_->Clear();
  clear_has_installer();
}
inline const ::buffers::resources::Installer& Settings::_internal_installer() const {
  return *installer_;
}
inline const ::buffers::resources::Installer& Settings::installer() const {
  const ::buffers::resources::Installer* p = installer_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.installer)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Installer*>(
      &::buffers::resources::_Installer_default_instance_);
}
inline ::buffers::resources::Installer* Settings::release_installer() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.installer)
  clear_has_installer();
  ::buffers::resources::Installer* temp = installer_;
  installer_ = NULL;
  return temp;
}
inline ::buffers::resources::Installer* Settings::mutable_installer() {
  set_has_installer();
  if (installer_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Installer>(GetArenaNoVirtual());
    installer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.installer)
  return installer_;
}
inline void Settings::set_allocated_installer(::buffers::resources::Installer* installer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete installer_;
  }
  if (installer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      installer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, installer, submessage_arena);
    }
    set_has_installer();
  } else {
    clear_has_installer();
  }
  installer_ = installer;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.installer)
}

// optional .buffers.resources.Deployment deployment = 7;
inline bool Settings::has_deployment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Settings::set_has_deployment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Settings::clear_has_deployment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Settings::clear_deployment() {
  if (deployment_ != NULL) deployment_->Clear();
  clear_has_deployment();
}
inline const ::buffers::resources::Deployment& Settings::_internal_deployment() const {
  return *deployment_;
}
inline const ::buffers::resources::Deployment& Settings::deployment() const {
  const ::buffers::resources::Deployment* p = deployment_;
  // @@protoc_insertion_point(field_get:buffers.resources.Settings.deployment)
  return p != NULL ? *p : *reinterpret_cast<const ::buffers::resources::Deployment*>(
      &::buffers::resources::_Deployment_default_instance_);
}
inline ::buffers::resources::Deployment* Settings::release_deployment() {
  // @@protoc_insertion_point(field_release:buffers.resources.Settings.deployment)
  clear_has_deployment();
  ::buffers::resources::Deployment* temp = deployment_;
  deployment_ = NULL;
  return temp;
}
inline ::buffers::resources::Deployment* Settings::mutable_deployment() {
  set_has_deployment();
  if (deployment_ == NULL) {
    auto* p = CreateMaybeMessage<::buffers::resources::Deployment>(GetArenaNoVirtual());
    deployment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:buffers.resources.Settings.deployment)
  return deployment_;
}
inline void Settings::set_allocated_deployment(::buffers::resources::Deployment* deployment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete deployment_;
  }
  if (deployment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deployment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deployment, submessage_arena);
    }
    set_has_deployment();
  } else {
    clear_has_deployment();
  }
  deployment_ = deployment;
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Settings.deployment)
}

// -------------------------------------------------------------------

// API

// optional string target_audio = 1;
inline bool API::has_target_audio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void API::set_has_target_audio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void API::clear_has_target_audio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void API::clear_target_audio() {
  target_audio_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_audio();
}
inline const ::std::string& API::target_audio() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_audio)
  return target_audio_.GetNoArena();
}
inline void API::set_target_audio(const ::std::string& value) {
  set_has_target_audio();
  target_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_audio)
}
#if LANG_CXX11
inline void API::set_target_audio(::std::string&& value) {
  set_has_target_audio();
  target_audio_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_audio)
}
#endif
inline void API::set_target_audio(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_audio();
  target_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_audio)
}
inline void API::set_target_audio(const char* value, size_t size) {
  set_has_target_audio();
  target_audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_audio)
}
inline ::std::string* API::mutable_target_audio() {
  set_has_target_audio();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_audio)
  return target_audio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_audio() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_audio)
  if (!has_target_audio()) {
    return NULL;
  }
  clear_has_target_audio();
  return target_audio_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_audio(::std::string* target_audio) {
  if (target_audio != NULL) {
    set_has_target_audio();
  } else {
    clear_has_target_audio();
  }
  target_audio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_audio);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_audio)
}

// optional string target_platform = 2;
inline bool API::has_target_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void API::set_has_target_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void API::clear_has_target_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void API::clear_target_platform() {
  target_platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_platform();
}
inline const ::std::string& API::target_platform() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_platform)
  return target_platform_.GetNoArena();
}
inline void API::set_target_platform(const ::std::string& value) {
  set_has_target_platform();
  target_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_platform)
}
#if LANG_CXX11
inline void API::set_target_platform(::std::string&& value) {
  set_has_target_platform();
  target_platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_platform)
}
#endif
inline void API::set_target_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_platform();
  target_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_platform)
}
inline void API::set_target_platform(const char* value, size_t size) {
  set_has_target_platform();
  target_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_platform)
}
inline ::std::string* API::mutable_target_platform() {
  set_has_target_platform();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_platform)
  return target_platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_platform() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_platform)
  if (!has_target_platform()) {
    return NULL;
  }
  clear_has_target_platform();
  return target_platform_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_platform(::std::string* target_platform) {
  if (target_platform != NULL) {
    set_has_target_platform();
  } else {
    clear_has_target_platform();
  }
  target_platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_platform);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_platform)
}

// optional string target_compiler = 3;
inline bool API::has_target_compiler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void API::set_has_target_compiler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void API::clear_has_target_compiler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void API::clear_target_compiler() {
  target_compiler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_compiler();
}
inline const ::std::string& API::target_compiler() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_compiler)
  return target_compiler_.GetNoArena();
}
inline void API::set_target_compiler(const ::std::string& value) {
  set_has_target_compiler();
  target_compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_compiler)
}
#if LANG_CXX11
inline void API::set_target_compiler(::std::string&& value) {
  set_has_target_compiler();
  target_compiler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_compiler)
}
#endif
inline void API::set_target_compiler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_compiler();
  target_compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_compiler)
}
inline void API::set_target_compiler(const char* value, size_t size) {
  set_has_target_compiler();
  target_compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_compiler)
}
inline ::std::string* API::mutable_target_compiler() {
  set_has_target_compiler();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_compiler)
  return target_compiler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_compiler() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_compiler)
  if (!has_target_compiler()) {
    return NULL;
  }
  clear_has_target_compiler();
  return target_compiler_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_compiler(::std::string* target_compiler) {
  if (target_compiler != NULL) {
    set_has_target_compiler();
  } else {
    clear_has_target_compiler();
  }
  target_compiler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_compiler);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_compiler)
}

// optional string target_graphics = 4;
inline bool API::has_target_graphics() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void API::set_has_target_graphics() {
  _has_bits_[0] |= 0x00000008u;
}
inline void API::clear_has_target_graphics() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void API::clear_target_graphics() {
  target_graphics_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_graphics();
}
inline const ::std::string& API::target_graphics() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_graphics)
  return target_graphics_.GetNoArena();
}
inline void API::set_target_graphics(const ::std::string& value) {
  set_has_target_graphics();
  target_graphics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_graphics)
}
#if LANG_CXX11
inline void API::set_target_graphics(::std::string&& value) {
  set_has_target_graphics();
  target_graphics_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_graphics)
}
#endif
inline void API::set_target_graphics(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_graphics();
  target_graphics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_graphics)
}
inline void API::set_target_graphics(const char* value, size_t size) {
  set_has_target_graphics();
  target_graphics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_graphics)
}
inline ::std::string* API::mutable_target_graphics() {
  set_has_target_graphics();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_graphics)
  return target_graphics_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_graphics() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_graphics)
  if (!has_target_graphics()) {
    return NULL;
  }
  clear_has_target_graphics();
  return target_graphics_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_graphics(::std::string* target_graphics) {
  if (target_graphics != NULL) {
    set_has_target_graphics();
  } else {
    clear_has_target_graphics();
  }
  target_graphics_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_graphics);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_graphics)
}

// optional string target_widgets = 5;
inline bool API::has_target_widgets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void API::set_has_target_widgets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void API::clear_has_target_widgets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void API::clear_target_widgets() {
  target_widgets_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_widgets();
}
inline const ::std::string& API::target_widgets() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_widgets)
  return target_widgets_.GetNoArena();
}
inline void API::set_target_widgets(const ::std::string& value) {
  set_has_target_widgets();
  target_widgets_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_widgets)
}
#if LANG_CXX11
inline void API::set_target_widgets(::std::string&& value) {
  set_has_target_widgets();
  target_widgets_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_widgets)
}
#endif
inline void API::set_target_widgets(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_widgets();
  target_widgets_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_widgets)
}
inline void API::set_target_widgets(const char* value, size_t size) {
  set_has_target_widgets();
  target_widgets_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_widgets)
}
inline ::std::string* API::mutable_target_widgets() {
  set_has_target_widgets();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_widgets)
  return target_widgets_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_widgets() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_widgets)
  if (!has_target_widgets()) {
    return NULL;
  }
  clear_has_target_widgets();
  return target_widgets_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_widgets(::std::string* target_widgets) {
  if (target_widgets != NULL) {
    set_has_target_widgets();
  } else {
    clear_has_target_widgets();
  }
  target_widgets_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_widgets);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_widgets)
}

// optional string target_collision = 6;
inline bool API::has_target_collision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void API::set_has_target_collision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void API::clear_has_target_collision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void API::clear_target_collision() {
  target_collision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_collision();
}
inline const ::std::string& API::target_collision() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_collision)
  return target_collision_.GetNoArena();
}
inline void API::set_target_collision(const ::std::string& value) {
  set_has_target_collision();
  target_collision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_collision)
}
#if LANG_CXX11
inline void API::set_target_collision(::std::string&& value) {
  set_has_target_collision();
  target_collision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_collision)
}
#endif
inline void API::set_target_collision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_collision();
  target_collision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_collision)
}
inline void API::set_target_collision(const char* value, size_t size) {
  set_has_target_collision();
  target_collision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_collision)
}
inline ::std::string* API::mutable_target_collision() {
  set_has_target_collision();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_collision)
  return target_collision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_collision() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_collision)
  if (!has_target_collision()) {
    return NULL;
  }
  clear_has_target_collision();
  return target_collision_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_collision(::std::string* target_collision) {
  if (target_collision != NULL) {
    set_has_target_collision();
  } else {
    clear_has_target_collision();
  }
  target_collision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_collision);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_collision)
}

// optional string target_network = 7;
inline bool API::has_target_network() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void API::set_has_target_network() {
  _has_bits_[0] |= 0x00000040u;
}
inline void API::clear_has_target_network() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void API::clear_target_network() {
  target_network_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_network();
}
inline const ::std::string& API::target_network() const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.target_network)
  return target_network_.GetNoArena();
}
inline void API::set_target_network(const ::std::string& value) {
  set_has_target_network();
  target_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.API.target_network)
}
#if LANG_CXX11
inline void API::set_target_network(::std::string&& value) {
  set_has_target_network();
  target_network_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.API.target_network)
}
#endif
inline void API::set_target_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_network();
  target_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.target_network)
}
inline void API::set_target_network(const char* value, size_t size) {
  set_has_target_network();
  target_network_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.target_network)
}
inline ::std::string* API::mutable_target_network() {
  set_has_target_network();
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.target_network)
  return target_network_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* API::release_target_network() {
  // @@protoc_insertion_point(field_release:buffers.resources.API.target_network)
  if (!has_target_network()) {
    return NULL;
  }
  clear_has_target_network();
  return target_network_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void API::set_allocated_target_network(::std::string* target_network) {
  if (target_network != NULL) {
    set_has_target_network();
  } else {
    clear_has_target_network();
  }
  target_network_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_network);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.API.target_network)
}

// repeated string extensions = 8;
inline int API::extensions_size() const {
  return extensions_.size();
}
inline void API::clear_extensions() {
  extensions_.Clear();
}
inline const ::std::string& API::extensions(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.API.extensions)
  return extensions_.Get(index);
}
inline ::std::string* API::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.API.extensions)
  return extensions_.Mutable(index);
}
inline void API::set_extensions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:buffers.resources.API.extensions)
  extensions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void API::set_extensions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:buffers.resources.API.extensions)
  extensions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void API::set_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffers.resources.API.extensions)
}
inline void API::set_extensions(int index, const char* value, size_t size) {
  extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.API.extensions)
}
inline ::std::string* API::add_extensions() {
  // @@protoc_insertion_point(field_add_mutable:buffers.resources.API.extensions)
  return extensions_.Add();
}
inline void API::add_extensions(const ::std::string& value) {
  extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffers.resources.API.extensions)
}
#if LANG_CXX11
inline void API::add_extensions(::std::string&& value) {
  extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffers.resources.API.extensions)
}
#endif
inline void API::add_extensions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffers.resources.API.extensions)
}
inline void API::add_extensions(const char* value, size_t size) {
  extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffers.resources.API.extensions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
API::extensions() const {
  // @@protoc_insertion_point(field_list:buffers.resources.API.extensions)
  return extensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
API::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.API.extensions)
  return &extensions_;
}

// -------------------------------------------------------------------

// Compiler

// optional uint32 inherit_strings = 1;
inline bool Compiler::has_inherit_strings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Compiler::set_has_inherit_strings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Compiler::clear_has_inherit_strings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Compiler::clear_inherit_strings() {
  inherit_strings_ = 0u;
  clear_has_inherit_strings();
}
inline ::google::protobuf::uint32 Compiler::inherit_strings() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_strings)
  return inherit_strings_;
}
inline void Compiler::set_inherit_strings(::google::protobuf::uint32 value) {
  set_has_inherit_strings();
  inherit_strings_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_strings)
}

// optional uint32 inherit_escapes = 2;
inline bool Compiler::has_inherit_escapes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Compiler::set_has_inherit_escapes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Compiler::clear_has_inherit_escapes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Compiler::clear_inherit_escapes() {
  inherit_escapes_ = 0u;
  clear_has_inherit_escapes();
}
inline ::google::protobuf::uint32 Compiler::inherit_escapes() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_escapes)
  return inherit_escapes_;
}
inline void Compiler::set_inherit_escapes(::google::protobuf::uint32 value) {
  set_has_inherit_escapes();
  inherit_escapes_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_escapes)
}

// optional uint32 inherit_increment = 3;
inline bool Compiler::has_inherit_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Compiler::set_has_inherit_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Compiler::clear_has_inherit_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Compiler::clear_inherit_increment() {
  inherit_increment_ = 0u;
  clear_has_inherit_increment();
}
inline ::google::protobuf::uint32 Compiler::inherit_increment() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_increment)
  return inherit_increment_;
}
inline void Compiler::set_inherit_increment(::google::protobuf::uint32 value) {
  set_has_inherit_increment();
  inherit_increment_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_increment)
}

// optional uint32 inherit_equivalence = 4;
inline bool Compiler::has_inherit_equivalence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Compiler::set_has_inherit_equivalence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Compiler::clear_has_inherit_equivalence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Compiler::clear_inherit_equivalence() {
  inherit_equivalence_ = 0u;
  clear_has_inherit_equivalence();
}
inline ::google::protobuf::uint32 Compiler::inherit_equivalence() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_equivalence)
  return inherit_equivalence_;
}
inline void Compiler::set_inherit_equivalence(::google::protobuf::uint32 value) {
  set_has_inherit_equivalence();
  inherit_equivalence_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_equivalence)
}

// optional uint32 inherit_literals = 5;
inline bool Compiler::has_inherit_literals() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Compiler::set_has_inherit_literals() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Compiler::clear_has_inherit_literals() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Compiler::clear_inherit_literals() {
  inherit_literals_ = 0u;
  clear_has_inherit_literals();
}
inline ::google::protobuf::uint32 Compiler::inherit_literals() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_literals)
  return inherit_literals_;
}
inline void Compiler::set_inherit_literals(::google::protobuf::uint32 value) {
  set_has_inherit_literals();
  inherit_literals_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_literals)
}

// optional uint32 inherit_negatives = 6;
inline bool Compiler::has_inherit_negatives() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Compiler::set_has_inherit_negatives() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Compiler::clear_has_inherit_negatives() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Compiler::clear_inherit_negatives() {
  inherit_negatives_ = 0u;
  clear_has_inherit_negatives();
}
inline ::google::protobuf::uint32 Compiler::inherit_negatives() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_negatives)
  return inherit_negatives_;
}
inline void Compiler::set_inherit_negatives(::google::protobuf::uint32 value) {
  set_has_inherit_negatives();
  inherit_negatives_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_negatives)
}

// optional uint32 compliance_mode = 7;
inline bool Compiler::has_compliance_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Compiler::set_has_compliance_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Compiler::clear_has_compliance_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Compiler::clear_compliance_mode() {
  compliance_mode_ = 0u;
  clear_has_compliance_mode();
}
inline ::google::protobuf::uint32 Compiler::compliance_mode() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.compliance_mode)
  return compliance_mode_;
}
inline void Compiler::set_compliance_mode(::google::protobuf::uint32 value) {
  set_has_compliance_mode();
  compliance_mode_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.compliance_mode)
}

// repeated string keyword_blacklist = 8;
inline int Compiler::keyword_blacklist_size() const {
  return keyword_blacklist_.size();
}
inline void Compiler::clear_keyword_blacklist() {
  keyword_blacklist_.Clear();
}
inline const ::std::string& Compiler::keyword_blacklist(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.keyword_blacklist)
  return keyword_blacklist_.Get(index);
}
inline ::std::string* Compiler::mutable_keyword_blacklist(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.Compiler.keyword_blacklist)
  return keyword_blacklist_.Mutable(index);
}
inline void Compiler::set_keyword_blacklist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.keyword_blacklist)
  keyword_blacklist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Compiler::set_keyword_blacklist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.keyword_blacklist)
  keyword_blacklist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Compiler::set_keyword_blacklist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keyword_blacklist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffers.resources.Compiler.keyword_blacklist)
}
inline void Compiler::set_keyword_blacklist(int index, const char* value, size_t size) {
  keyword_blacklist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Compiler.keyword_blacklist)
}
inline ::std::string* Compiler::add_keyword_blacklist() {
  // @@protoc_insertion_point(field_add_mutable:buffers.resources.Compiler.keyword_blacklist)
  return keyword_blacklist_.Add();
}
inline void Compiler::add_keyword_blacklist(const ::std::string& value) {
  keyword_blacklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffers.resources.Compiler.keyword_blacklist)
}
#if LANG_CXX11
inline void Compiler::add_keyword_blacklist(::std::string&& value) {
  keyword_blacklist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffers.resources.Compiler.keyword_blacklist)
}
#endif
inline void Compiler::add_keyword_blacklist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keyword_blacklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffers.resources.Compiler.keyword_blacklist)
}
inline void Compiler::add_keyword_blacklist(const char* value, size_t size) {
  keyword_blacklist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffers.resources.Compiler.keyword_blacklist)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Compiler::keyword_blacklist() const {
  // @@protoc_insertion_point(field_list:buffers.resources.Compiler.keyword_blacklist)
  return keyword_blacklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Compiler::mutable_keyword_blacklist() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.Compiler.keyword_blacklist)
  return &keyword_blacklist_;
}

// optional string eobjs_directory = 9;
inline bool Compiler::has_eobjs_directory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Compiler::set_has_eobjs_directory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Compiler::clear_has_eobjs_directory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Compiler::clear_eobjs_directory() {
  eobjs_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_eobjs_directory();
}
inline const ::std::string& Compiler::eobjs_directory() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.eobjs_directory)
  return eobjs_directory_.GetNoArena();
}
inline void Compiler::set_eobjs_directory(const ::std::string& value) {
  set_has_eobjs_directory();
  eobjs_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.eobjs_directory)
}
#if LANG_CXX11
inline void Compiler::set_eobjs_directory(::std::string&& value) {
  set_has_eobjs_directory();
  eobjs_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Compiler.eobjs_directory)
}
#endif
inline void Compiler::set_eobjs_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_eobjs_directory();
  eobjs_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Compiler.eobjs_directory)
}
inline void Compiler::set_eobjs_directory(const char* value, size_t size) {
  set_has_eobjs_directory();
  eobjs_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Compiler.eobjs_directory)
}
inline ::std::string* Compiler::mutable_eobjs_directory() {
  set_has_eobjs_directory();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Compiler.eobjs_directory)
  return eobjs_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Compiler::release_eobjs_directory() {
  // @@protoc_insertion_point(field_release:buffers.resources.Compiler.eobjs_directory)
  if (!has_eobjs_directory()) {
    return NULL;
  }
  clear_has_eobjs_directory();
  return eobjs_directory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Compiler::set_allocated_eobjs_directory(::std::string* eobjs_directory) {
  if (eobjs_directory != NULL) {
    set_has_eobjs_directory();
  } else {
    clear_has_eobjs_directory();
  }
  eobjs_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), eobjs_directory);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Compiler.eobjs_directory)
}

// optional string codegen_directory = 10;
inline bool Compiler::has_codegen_directory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Compiler::set_has_codegen_directory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Compiler::clear_has_codegen_directory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Compiler::clear_codegen_directory() {
  codegen_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_codegen_directory();
}
inline const ::std::string& Compiler::codegen_directory() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.codegen_directory)
  return codegen_directory_.GetNoArena();
}
inline void Compiler::set_codegen_directory(const ::std::string& value) {
  set_has_codegen_directory();
  codegen_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.codegen_directory)
}
#if LANG_CXX11
inline void Compiler::set_codegen_directory(::std::string&& value) {
  set_has_codegen_directory();
  codegen_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Compiler.codegen_directory)
}
#endif
inline void Compiler::set_codegen_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_codegen_directory();
  codegen_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Compiler.codegen_directory)
}
inline void Compiler::set_codegen_directory(const char* value, size_t size) {
  set_has_codegen_directory();
  codegen_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Compiler.codegen_directory)
}
inline ::std::string* Compiler::mutable_codegen_directory() {
  set_has_codegen_directory();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Compiler.codegen_directory)
  return codegen_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Compiler::release_codegen_directory() {
  // @@protoc_insertion_point(field_release:buffers.resources.Compiler.codegen_directory)
  if (!has_codegen_directory()) {
    return NULL;
  }
  clear_has_codegen_directory();
  return codegen_directory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Compiler::set_allocated_codegen_directory(::std::string* codegen_directory) {
  if (codegen_directory != NULL) {
    set_has_codegen_directory();
  } else {
    clear_has_codegen_directory();
  }
  codegen_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codegen_directory);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Compiler.codegen_directory)
}

// optional bool inherit_objects = 11;
inline bool Compiler::has_inherit_objects() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Compiler::set_has_inherit_objects() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Compiler::clear_has_inherit_objects() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Compiler::clear_inherit_objects() {
  inherit_objects_ = false;
  clear_has_inherit_objects();
}
inline bool Compiler::inherit_objects() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.inherit_objects)
  return inherit_objects_;
}
inline void Compiler::set_inherit_objects(bool value) {
  set_has_inherit_objects();
  inherit_objects_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.inherit_objects)
}

// optional bool automatic_semicolons = 12;
inline bool Compiler::has_automatic_semicolons() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Compiler::set_has_automatic_semicolons() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Compiler::clear_has_automatic_semicolons() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Compiler::clear_automatic_semicolons() {
  automatic_semicolons_ = false;
  clear_has_automatic_semicolons();
}
inline bool Compiler::automatic_semicolons() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.automatic_semicolons)
  return automatic_semicolons_;
}
inline void Compiler::set_automatic_semicolons(bool value) {
  set_has_automatic_semicolons();
  automatic_semicolons_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.automatic_semicolons)
}

// optional uint32 graphics_angular_unit = 13;
inline bool Compiler::has_graphics_angular_unit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Compiler::set_has_graphics_angular_unit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Compiler::clear_has_graphics_angular_unit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Compiler::clear_graphics_angular_unit() {
  graphics_angular_unit_ = 0u;
  clear_has_graphics_angular_unit();
}
inline ::google::protobuf::uint32 Compiler::graphics_angular_unit() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.graphics_angular_unit)
  return graphics_angular_unit_;
}
inline void Compiler::set_graphics_angular_unit(::google::protobuf::uint32 value) {
  set_has_graphics_angular_unit();
  graphics_angular_unit_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.graphics_angular_unit)
}

// optional uint32 graphics_scalar_precision = 14;
inline bool Compiler::has_graphics_scalar_precision() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Compiler::set_has_graphics_scalar_precision() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Compiler::clear_has_graphics_scalar_precision() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Compiler::clear_graphics_scalar_precision() {
  graphics_scalar_precision_ = 0u;
  clear_has_graphics_scalar_precision();
}
inline ::google::protobuf::uint32 Compiler::graphics_scalar_precision() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.graphics_scalar_precision)
  return graphics_scalar_precision_;
}
inline void Compiler::set_graphics_scalar_precision(::google::protobuf::uint32 value) {
  set_has_graphics_scalar_precision();
  graphics_scalar_precision_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.graphics_scalar_precision)
}

// optional uint32 collision_angular_unit = 15;
inline bool Compiler::has_collision_angular_unit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Compiler::set_has_collision_angular_unit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Compiler::clear_has_collision_angular_unit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Compiler::clear_collision_angular_unit() {
  collision_angular_unit_ = 0u;
  clear_has_collision_angular_unit();
}
inline ::google::protobuf::uint32 Compiler::collision_angular_unit() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.collision_angular_unit)
  return collision_angular_unit_;
}
inline void Compiler::set_collision_angular_unit(::google::protobuf::uint32 value) {
  set_has_collision_angular_unit();
  collision_angular_unit_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.collision_angular_unit)
}

// optional uint32 collision_scalar_precision = 16;
inline bool Compiler::has_collision_scalar_precision() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Compiler::set_has_collision_scalar_precision() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Compiler::clear_has_collision_scalar_precision() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Compiler::clear_collision_scalar_precision() {
  collision_scalar_precision_ = 0u;
  clear_has_collision_scalar_precision();
}
inline ::google::protobuf::uint32 Compiler::collision_scalar_precision() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.collision_scalar_precision)
  return collision_scalar_precision_;
}
inline void Compiler::set_collision_scalar_precision(::google::protobuf::uint32 value) {
  set_has_collision_scalar_precision();
  collision_scalar_precision_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.collision_scalar_precision)
}

// optional uint32 audio_angular_unit = 17;
inline bool Compiler::has_audio_angular_unit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Compiler::set_has_audio_angular_unit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Compiler::clear_has_audio_angular_unit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Compiler::clear_audio_angular_unit() {
  audio_angular_unit_ = 0u;
  clear_has_audio_angular_unit();
}
inline ::google::protobuf::uint32 Compiler::audio_angular_unit() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.audio_angular_unit)
  return audio_angular_unit_;
}
inline void Compiler::set_audio_angular_unit(::google::protobuf::uint32 value) {
  set_has_audio_angular_unit();
  audio_angular_unit_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.audio_angular_unit)
}

// optional uint32 audio_scalar_precision = 18;
inline bool Compiler::has_audio_scalar_precision() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Compiler::set_has_audio_scalar_precision() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Compiler::clear_has_audio_scalar_precision() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Compiler::clear_audio_scalar_precision() {
  audio_scalar_precision_ = 0u;
  clear_has_audio_scalar_precision();
}
inline ::google::protobuf::uint32 Compiler::audio_scalar_precision() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Compiler.audio_scalar_precision)
  return audio_scalar_precision_;
}
inline void Compiler::set_audio_scalar_precision(::google::protobuf::uint32 value) {
  set_has_audio_scalar_precision();
  audio_scalar_precision_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Compiler.audio_scalar_precision)
}

// -------------------------------------------------------------------

// General

// optional uint64 game_id = 1 [(.buffers.gmx) = "option_gameid"];
inline bool General::has_game_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void General::set_has_game_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void General::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void General::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 General::game_id() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.game_id)
  return game_id_;
}
inline void General::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.game_id)
}

// optional string game_guid = 2 [(.buffers.gmx) = "option_gameguid"];
inline bool General::has_game_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void General::set_has_game_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void General::clear_has_game_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void General::clear_game_guid() {
  game_guid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_guid();
}
inline const ::std::string& General::game_guid() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.game_guid)
  return game_guid_.GetNoArena();
}
inline void General::set_game_guid(const ::std::string& value) {
  set_has_game_guid();
  game_guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.game_guid)
}
#if LANG_CXX11
inline void General::set_game_guid(::std::string&& value) {
  set_has_game_guid();
  game_guid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.game_guid)
}
#endif
inline void General::set_game_guid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_guid();
  game_guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.game_guid)
}
inline void General::set_game_guid(const char* value, size_t size) {
  set_has_game_guid();
  game_guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.game_guid)
}
inline ::std::string* General::mutable_game_guid() {
  set_has_game_guid();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.game_guid)
  return game_guid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_game_guid() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.game_guid)
  if (!has_game_guid()) {
    return NULL;
  }
  clear_has_game_guid();
  return game_guid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_game_guid(::std::string* game_guid) {
  if (game_guid != NULL) {
    set_has_game_guid();
  } else {
    clear_has_game_guid();
  }
  game_guid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_guid);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.game_guid)
}

// optional int32 color_outside_room_region = 3 [(.buffers.gmx) = "option_windowcolor"];
inline bool General::has_color_outside_room_region() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void General::set_has_color_outside_room_region() {
  _has_bits_[0] |= 0x00000400u;
}
inline void General::clear_has_color_outside_room_region() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void General::clear_color_outside_room_region() {
  color_outside_room_region_ = 0;
  clear_has_color_outside_room_region();
}
inline ::google::protobuf::int32 General::color_outside_room_region() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.color_outside_room_region)
  return color_outside_room_region_;
}
inline void General::set_color_outside_room_region(::google::protobuf::int32 value) {
  set_has_color_outside_room_region();
  color_outside_room_region_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.color_outside_room_region)
}

// optional string display_name = 4 [(.buffers.gmx) = "option_display_name"];
inline bool General::has_display_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void General::set_has_display_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void General::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void General::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_display_name();
}
inline const ::std::string& General::display_name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.display_name)
  return display_name_.GetNoArena();
}
inline void General::set_display_name(const ::std::string& value) {
  set_has_display_name();
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.display_name)
}
#if LANG_CXX11
inline void General::set_display_name(::std::string&& value) {
  set_has_display_name();
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.display_name)
}
#endif
inline void General::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_display_name();
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.display_name)
}
inline void General::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.display_name)
}
inline ::std::string* General::mutable_display_name() {
  set_has_display_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_display_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.display_name)
  if (!has_display_name()) {
    return NULL;
  }
  clear_has_display_name();
  return display_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    set_has_display_name();
  } else {
    clear_has_display_name();
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.display_name)
}

// optional uint32 version_major = 5 [(.buffers.gmx) = "option_version_major"];
inline bool General::has_version_major() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void General::set_has_version_major() {
  _has_bits_[0] |= 0x00000800u;
}
inline void General::clear_has_version_major() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void General::clear_version_major() {
  version_major_ = 0u;
  clear_has_version_major();
}
inline ::google::protobuf::uint32 General::version_major() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.version_major)
  return version_major_;
}
inline void General::set_version_major(::google::protobuf::uint32 value) {
  set_has_version_major();
  version_major_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.version_major)
}

// optional uint32 version_minor = 6 [(.buffers.gmx) = "option_version_minor"];
inline bool General::has_version_minor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void General::set_has_version_minor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void General::clear_has_version_minor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void General::clear_version_minor() {
  version_minor_ = 0u;
  clear_has_version_minor();
}
inline ::google::protobuf::uint32 General::version_minor() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.version_minor)
  return version_minor_;
}
inline void General::set_version_minor(::google::protobuf::uint32 value) {
  set_has_version_minor();
  version_minor_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.version_minor)
}

// optional uint32 version_release = 7 [(.buffers.gmx) = "option_version_release"];
inline bool General::has_version_release() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void General::set_has_version_release() {
  _has_bits_[0] |= 0x00002000u;
}
inline void General::clear_has_version_release() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void General::clear_version_release() {
  version_release_ = 0u;
  clear_has_version_release();
}
inline ::google::protobuf::uint32 General::version_release() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.version_release)
  return version_release_;
}
inline void General::set_version_release(::google::protobuf::uint32 value) {
  set_has_version_release();
  version_release_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.version_release)
}

// optional uint32 version_build = 8 [(.buffers.gmx) = "option_version_build"];
inline bool General::has_version_build() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void General::set_has_version_build() {
  _has_bits_[0] |= 0x00004000u;
}
inline void General::clear_has_version_build() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void General::clear_version_build() {
  version_build_ = 0u;
  clear_has_version_build();
}
inline ::google::protobuf::uint32 General::version_build() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.version_build)
  return version_build_;
}
inline void General::set_version_build(::google::protobuf::uint32 value) {
  set_has_version_build();
  version_build_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.version_build)
}

// optional string company = 9 [(.buffers.gmx) = "option_version_company"];
inline bool General::has_company() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void General::set_has_company() {
  _has_bits_[0] |= 0x00000004u;
}
inline void General::clear_has_company() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void General::clear_company() {
  company_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_company();
}
inline const ::std::string& General::company() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.company)
  return company_.GetNoArena();
}
inline void General::set_company(const ::std::string& value) {
  set_has_company();
  company_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.company)
}
#if LANG_CXX11
inline void General::set_company(::std::string&& value) {
  set_has_company();
  company_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.company)
}
#endif
inline void General::set_company(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_company();
  company_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.company)
}
inline void General::set_company(const char* value, size_t size) {
  set_has_company();
  company_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.company)
}
inline ::std::string* General::mutable_company() {
  set_has_company();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.company)
  return company_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_company() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.company)
  if (!has_company()) {
    return NULL;
  }
  clear_has_company();
  return company_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_company(::std::string* company) {
  if (company != NULL) {
    set_has_company();
  } else {
    clear_has_company();
  }
  company_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), company);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.company)
}

// optional string product = 10 [(.buffers.gmx) = "option_version_product"];
inline bool General::has_product() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void General::set_has_product() {
  _has_bits_[0] |= 0x00000008u;
}
inline void General::clear_has_product() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void General::clear_product() {
  product_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_product();
}
inline const ::std::string& General::product() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.product)
  return product_.GetNoArena();
}
inline void General::set_product(const ::std::string& value) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.product)
}
#if LANG_CXX11
inline void General::set_product(::std::string&& value) {
  set_has_product();
  product_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.product)
}
#endif
inline void General::set_product(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.product)
}
inline void General::set_product(const char* value, size_t size) {
  set_has_product();
  product_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.product)
}
inline ::std::string* General::mutable_product() {
  set_has_product();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.product)
  return product_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_product() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.product)
  if (!has_product()) {
    return NULL;
  }
  clear_has_product();
  return product_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_product(::std::string* product) {
  if (product != NULL) {
    set_has_product();
  } else {
    clear_has_product();
  }
  product_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.product)
}

// optional string copyright = 11 [(.buffers.gmx) = "option_version_copyright"];
inline bool General::has_copyright() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void General::set_has_copyright() {
  _has_bits_[0] |= 0x00000010u;
}
inline void General::clear_has_copyright() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void General::clear_copyright() {
  copyright_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_copyright();
}
inline const ::std::string& General::copyright() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.copyright)
  return copyright_.GetNoArena();
}
inline void General::set_copyright(const ::std::string& value) {
  set_has_copyright();
  copyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.copyright)
}
#if LANG_CXX11
inline void General::set_copyright(::std::string&& value) {
  set_has_copyright();
  copyright_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.copyright)
}
#endif
inline void General::set_copyright(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_copyright();
  copyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.copyright)
}
inline void General::set_copyright(const char* value, size_t size) {
  set_has_copyright();
  copyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.copyright)
}
inline ::std::string* General::mutable_copyright() {
  set_has_copyright();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.copyright)
  return copyright_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_copyright() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.copyright)
  if (!has_copyright()) {
    return NULL;
  }
  clear_has_copyright();
  return copyright_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_copyright(::std::string* copyright) {
  if (copyright != NULL) {
    set_has_copyright();
  } else {
    clear_has_copyright();
  }
  copyright_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), copyright);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.copyright)
}

// optional string description = 12 [(.buffers.gmx) = "option_version_description"];
inline bool General::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void General::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void General::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void General::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& General::description() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.description)
  return description_.GetNoArena();
}
inline void General::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.description)
}
#if LANG_CXX11
inline void General::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.description)
}
#endif
inline void General::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.description)
}
inline void General::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.description)
}
inline ::std::string* General::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_description() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.description)
}

// optional bool show_cursor = 13 [(.buffers.gmx) = "option_showcursor"];
inline bool General::has_show_cursor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void General::set_has_show_cursor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void General::clear_has_show_cursor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void General::clear_show_cursor() {
  show_cursor_ = false;
  clear_has_show_cursor();
}
inline bool General::show_cursor() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.show_cursor)
  return show_cursor_;
}
inline void General::set_show_cursor(bool value) {
  set_has_show_cursor();
  show_cursor_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.show_cursor)
}

// optional string game_icon = 14 [(.buffers.gmx) = "option_windows_game_icon"];
inline bool General::has_game_icon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void General::set_has_game_icon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void General::clear_has_game_icon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void General::clear_game_icon() {
  game_icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_icon();
}
inline const ::std::string& General::game_icon() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.game_icon)
  return game_icon_.GetNoArena();
}
inline void General::set_game_icon(const ::std::string& value) {
  set_has_game_icon();
  game_icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.game_icon)
}
#if LANG_CXX11
inline void General::set_game_icon(::std::string&& value) {
  set_has_game_icon();
  game_icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.game_icon)
}
#endif
inline void General::set_game_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_icon();
  game_icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.game_icon)
}
inline void General::set_game_icon(const char* value, size_t size) {
  set_has_game_icon();
  game_icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.game_icon)
}
inline ::std::string* General::mutable_game_icon() {
  set_has_game_icon();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.game_icon)
  return game_icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_game_icon() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.game_icon)
  if (!has_game_icon()) {
    return NULL;
  }
  clear_has_game_icon();
  return game_icon_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_game_icon(::std::string* game_icon) {
  if (game_icon != NULL) {
    set_has_game_icon();
  } else {
    clear_has_game_icon();
  }
  game_icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_icon);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.game_icon)
}

// optional string splash_screen = 15 [(.buffers.gmx) = "option_windows_splash_screen"];
inline bool General::has_splash_screen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void General::set_has_splash_screen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void General::clear_has_splash_screen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void General::clear_splash_screen() {
  splash_screen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_splash_screen();
}
inline const ::std::string& General::splash_screen() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.splash_screen)
  return splash_screen_.GetNoArena();
}
inline void General::set_splash_screen(const ::std::string& value) {
  set_has_splash_screen();
  splash_screen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.splash_screen)
}
#if LANG_CXX11
inline void General::set_splash_screen(::std::string&& value) {
  set_has_splash_screen();
  splash_screen_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.splash_screen)
}
#endif
inline void General::set_splash_screen(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_splash_screen();
  splash_screen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.splash_screen)
}
inline void General::set_splash_screen(const char* value, size_t size) {
  set_has_splash_screen();
  splash_screen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.splash_screen)
}
inline ::std::string* General::mutable_splash_screen() {
  set_has_splash_screen();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.splash_screen)
  return splash_screen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_splash_screen() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.splash_screen)
  if (!has_splash_screen()) {
    return NULL;
  }
  clear_has_splash_screen();
  return splash_screen_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_splash_screen(::std::string* splash_screen) {
  if (splash_screen != NULL) {
    set_has_splash_screen();
  } else {
    clear_has_splash_screen();
  }
  splash_screen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), splash_screen);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.splash_screen)
}

// optional bool show_splash_screen = 16 [(.buffers.gmx) = "option_windows_use_splash"];
inline bool General::has_show_splash_screen() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void General::set_has_show_splash_screen() {
  _has_bits_[0] |= 0x00010000u;
}
inline void General::clear_has_show_splash_screen() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void General::clear_show_splash_screen() {
  show_splash_screen_ = false;
  clear_has_show_splash_screen();
}
inline bool General::show_splash_screen() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.show_splash_screen)
  return show_splash_screen_;
}
inline void General::set_show_splash_screen(bool value) {
  set_has_show_splash_screen();
  show_splash_screen_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.show_splash_screen)
}

// optional uint32 sleep_margin = 17 [(.buffers.gmx) = "option_windows_sleep_margin"];
inline bool General::has_sleep_margin() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void General::set_has_sleep_margin() {
  _has_bits_[0] |= 0x00040000u;
}
inline void General::clear_has_sleep_margin() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void General::clear_sleep_margin() {
  sleep_margin_ = 0u;
  clear_has_sleep_margin();
}
inline ::google::protobuf::uint32 General::sleep_margin() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.sleep_margin)
  return sleep_margin_;
}
inline void General::set_sleep_margin(::google::protobuf::uint32 value) {
  set_has_sleep_margin();
  sleep_margin_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.sleep_margin)
}

// optional string save_data_location = 18 [(.buffers.gmx) = "option_windows_save_location"];
inline bool General::has_save_data_location() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void General::set_has_save_data_location() {
  _has_bits_[0] |= 0x00000100u;
}
inline void General::clear_has_save_data_location() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void General::clear_save_data_location() {
  save_data_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_save_data_location();
}
inline const ::std::string& General::save_data_location() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.save_data_location)
  return save_data_location_.GetNoArena();
}
inline void General::set_save_data_location(const ::std::string& value) {
  set_has_save_data_location();
  save_data_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.General.save_data_location)
}
#if LANG_CXX11
inline void General::set_save_data_location(::std::string&& value) {
  set_has_save_data_location();
  save_data_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.General.save_data_location)
}
#endif
inline void General::set_save_data_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_save_data_location();
  save_data_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.General.save_data_location)
}
inline void General::set_save_data_location(const char* value, size_t size) {
  set_has_save_data_location();
  save_data_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.General.save_data_location)
}
inline ::std::string* General::mutable_save_data_location() {
  set_has_save_data_location();
  // @@protoc_insertion_point(field_mutable:buffers.resources.General.save_data_location)
  return save_data_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* General::release_save_data_location() {
  // @@protoc_insertion_point(field_release:buffers.resources.General.save_data_location)
  if (!has_save_data_location()) {
    return NULL;
  }
  clear_has_save_data_location();
  return save_data_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void General::set_allocated_save_data_location(::std::string* save_data_location) {
  if (save_data_location != NULL) {
    set_has_save_data_location();
  } else {
    clear_has_save_data_location();
  }
  save_data_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), save_data_location);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.General.save_data_location)
}

// optional bool menu_dock = 19 [(.buffers.gmx) = "option_mac_menu_dock"];
inline bool General::has_menu_dock() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void General::set_has_menu_dock() {
  _has_bits_[0] |= 0x00020000u;
}
inline void General::clear_has_menu_dock() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void General::clear_menu_dock() {
  menu_dock_ = false;
  clear_has_menu_dock();
}
inline bool General::menu_dock() const {
  // @@protoc_insertion_point(field_get:buffers.resources.General.menu_dock)
  return menu_dock_;
}
inline void General::set_menu_dock(bool value) {
  set_has_menu_dock();
  menu_dock_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.General.menu_dock)
}

// -------------------------------------------------------------------

// Graphics

// optional bool start_in_fullscreen = 1 [(.buffers.gmx) = "option_fullscreen"];
inline bool Graphics::has_start_in_fullscreen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Graphics::set_has_start_in_fullscreen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Graphics::clear_has_start_in_fullscreen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Graphics::clear_start_in_fullscreen() {
  start_in_fullscreen_ = false;
  clear_has_start_in_fullscreen();
}
inline bool Graphics::start_in_fullscreen() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.start_in_fullscreen)
  return start_in_fullscreen_;
}
inline void Graphics::set_start_in_fullscreen(bool value) {
  set_has_start_in_fullscreen();
  start_in_fullscreen_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.start_in_fullscreen)
}

// optional bool allow_fullscreen_change = 2 [(.buffers.gmx) = "option_screenkey"];
inline bool Graphics::has_allow_fullscreen_change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Graphics::set_has_allow_fullscreen_change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Graphics::clear_has_allow_fullscreen_change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Graphics::clear_allow_fullscreen_change() {
  allow_fullscreen_change_ = false;
  clear_has_allow_fullscreen_change();
}
inline bool Graphics::allow_fullscreen_change() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.allow_fullscreen_change)
  return allow_fullscreen_change_;
}
inline void Graphics::set_allow_fullscreen_change(bool value) {
  set_has_allow_fullscreen_change();
  allow_fullscreen_change_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.allow_fullscreen_change)
}

// optional bool smooth_colors = 3 [(.buffers.gmx) = "option_interpolate"];
inline bool Graphics::has_smooth_colors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Graphics::set_has_smooth_colors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Graphics::clear_has_smooth_colors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Graphics::clear_smooth_colors() {
  smooth_colors_ = false;
  clear_has_smooth_colors();
}
inline bool Graphics::smooth_colors() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.smooth_colors)
  return smooth_colors_;
}
inline void Graphics::set_smooth_colors(bool value) {
  set_has_smooth_colors();
  smooth_colors_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.smooth_colors)
}

// optional bool force_software_vertex_processing = 4 [(.buffers.gmx) = ""];
inline bool Graphics::has_force_software_vertex_processing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Graphics::set_has_force_software_vertex_processing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Graphics::clear_has_force_software_vertex_processing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Graphics::clear_force_software_vertex_processing() {
  force_software_vertex_processing_ = false;
  clear_has_force_software_vertex_processing();
}
inline bool Graphics::force_software_vertex_processing() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.force_software_vertex_processing)
  return force_software_vertex_processing_;
}
inline void Graphics::set_force_software_vertex_processing(bool value) {
  set_has_force_software_vertex_processing();
  force_software_vertex_processing_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.force_software_vertex_processing)
}

// optional bool freeze_on_lose_focus = 5 [(.buffers.gmx) = "option_freeze"];
inline bool Graphics::has_freeze_on_lose_focus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Graphics::set_has_freeze_on_lose_focus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Graphics::clear_has_freeze_on_lose_focus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Graphics::clear_freeze_on_lose_focus() {
  freeze_on_lose_focus_ = false;
  clear_has_freeze_on_lose_focus();
}
inline bool Graphics::freeze_on_lose_focus() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.freeze_on_lose_focus)
  return freeze_on_lose_focus_;
}
inline void Graphics::set_freeze_on_lose_focus(bool value) {
  set_has_freeze_on_lose_focus();
  freeze_on_lose_focus_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.freeze_on_lose_focus)
}

// optional bool use_synchronization = 6 [(.buffers.gmx) = ""];
inline bool Graphics::has_use_synchronization() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Graphics::set_has_use_synchronization() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Graphics::clear_has_use_synchronization() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Graphics::clear_use_synchronization() {
  use_synchronization_ = false;
  clear_has_use_synchronization();
}
inline bool Graphics::use_synchronization() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.use_synchronization)
  return use_synchronization_;
}
inline void Graphics::set_use_synchronization(bool value) {
  set_has_use_synchronization();
  use_synchronization_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.use_synchronization)
}

// optional bool window_sizeable = 7 [(.buffers.gmx) = "option_sizeable"];
inline bool Graphics::has_window_sizeable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Graphics::set_has_window_sizeable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Graphics::clear_has_window_sizeable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Graphics::clear_window_sizeable() {
  window_sizeable_ = false;
  clear_has_window_sizeable();
}
inline bool Graphics::window_sizeable() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.window_sizeable)
  return window_sizeable_;
}
inline void Graphics::set_window_sizeable(bool value) {
  set_has_window_sizeable();
  window_sizeable_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.window_sizeable)
}

// optional bool window_showborder = 8 [(.buffers.gmx) = "option_noborder"];
inline bool Graphics::has_window_showborder() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Graphics::set_has_window_showborder() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Graphics::clear_has_window_showborder() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Graphics::clear_window_showborder() {
  window_showborder_ = false;
  clear_has_window_showborder();
}
inline bool Graphics::window_showborder() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.window_showborder)
  return window_showborder_;
}
inline void Graphics::set_window_showborder(bool value) {
  set_has_window_showborder();
  window_showborder_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.window_showborder)
}

// optional bool window_showicons = 9 [(.buffers.gmx) = "option_nobuttons"];
inline bool Graphics::has_window_showicons() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Graphics::set_has_window_showicons() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Graphics::clear_has_window_showicons() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Graphics::clear_window_showicons() {
  window_showicons_ = false;
  clear_has_window_showicons();
}
inline bool Graphics::window_showicons() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.window_showicons)
  return window_showicons_;
}
inline void Graphics::set_window_showicons(bool value) {
  set_has_window_showicons();
  window_showicons_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.window_showicons)
}

// optional bool window_stayontop = 10 [(.buffers.gmx) = "option_stayontop"];
inline bool Graphics::has_window_stayontop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Graphics::set_has_window_stayontop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Graphics::clear_has_window_stayontop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Graphics::clear_window_stayontop() {
  window_stayontop_ = false;
  clear_has_window_stayontop();
}
inline bool Graphics::window_stayontop() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.window_stayontop)
  return window_stayontop_;
}
inline void Graphics::set_window_stayontop(bool value) {
  set_has_window_stayontop();
  window_stayontop_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.window_stayontop)
}

// optional double window_scale = 11 [(.buffers.gmx) = "option_scale"];
inline bool Graphics::has_window_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Graphics::set_has_window_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Graphics::clear_has_window_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Graphics::clear_window_scale() {
  window_scale_ = 0;
  clear_has_window_scale();
}
inline double Graphics::window_scale() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.window_scale)
  return window_scale_;
}
inline void Graphics::set_window_scale(double value) {
  set_has_window_scale();
  window_scale_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.window_scale)
}

// optional bool create_textures_on_demand = 12 [(.buffers.gmx) = "option_windows_create_textures_on_demand"];
inline bool Graphics::has_create_textures_on_demand() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Graphics::set_has_create_textures_on_demand() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Graphics::clear_has_create_textures_on_demand() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Graphics::clear_create_textures_on_demand() {
  create_textures_on_demand_ = false;
  clear_has_create_textures_on_demand();
}
inline bool Graphics::create_textures_on_demand() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.create_textures_on_demand)
  return create_textures_on_demand_;
}
inline void Graphics::set_create_textures_on_demand(bool value) {
  set_has_create_textures_on_demand();
  create_textures_on_demand_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.create_textures_on_demand)
}

// optional bool alternate_synchronization_method = 13 [(.buffers.gmx) = "option_windows_alternate_sync_method"];
inline bool Graphics::has_alternate_synchronization_method() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Graphics::set_has_alternate_synchronization_method() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Graphics::clear_has_alternate_synchronization_method() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Graphics::clear_alternate_synchronization_method() {
  alternate_synchronization_method_ = false;
  clear_has_alternate_synchronization_method();
}
inline bool Graphics::alternate_synchronization_method() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.alternate_synchronization_method)
  return alternate_synchronization_method_;
}
inline void Graphics::set_alternate_synchronization_method(bool value) {
  set_has_alternate_synchronization_method();
  alternate_synchronization_method_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.alternate_synchronization_method)
}

// optional .buffers.resources.Graphics.VertexBufferMethod vertex_buffer_method = 14 [(.buffers.gmx) = "option_windows_vertex_buffer_method2"];
inline bool Graphics::has_vertex_buffer_method() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Graphics::set_has_vertex_buffer_method() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Graphics::clear_has_vertex_buffer_method() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Graphics::clear_vertex_buffer_method() {
  vertex_buffer_method_ = 0;
  clear_has_vertex_buffer_method();
}
inline ::buffers::resources::Graphics_VertexBufferMethod Graphics::vertex_buffer_method() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.vertex_buffer_method)
  return static_cast< ::buffers::resources::Graphics_VertexBufferMethod >(vertex_buffer_method_);
}
inline void Graphics::set_vertex_buffer_method(::buffers::resources::Graphics_VertexBufferMethod value) {
  assert(::buffers::resources::Graphics_VertexBufferMethod_IsValid(value));
  set_has_vertex_buffer_method();
  vertex_buffer_method_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.vertex_buffer_method)
}

// optional uint32 texture_page_size = 15 [(.buffers.gmx) = "option_windows_texture_page"];
inline bool Graphics::has_texture_page_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Graphics::set_has_texture_page_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Graphics::clear_has_texture_page_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Graphics::clear_texture_page_size() {
  texture_page_size_ = 0u;
  clear_has_texture_page_size();
}
inline ::google::protobuf::uint32 Graphics::texture_page_size() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.texture_page_size)
  return texture_page_size_;
}
inline void Graphics::set_texture_page_size(::google::protobuf::uint32 value) {
  set_has_texture_page_size();
  texture_page_size_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.texture_page_size)
}

// optional bool enable_hidpi = 16 [(.buffers.gmx) = "option_mac_enable_retina"];
inline bool Graphics::has_enable_hidpi() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Graphics::set_has_enable_hidpi() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Graphics::clear_has_enable_hidpi() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Graphics::clear_enable_hidpi() {
  enable_hidpi_ = false;
  clear_has_enable_hidpi();
}
inline bool Graphics::enable_hidpi() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Graphics.enable_hidpi)
  return enable_hidpi_;
}
inline void Graphics::set_enable_hidpi(bool value) {
  set_has_enable_hidpi();
  enable_hidpi_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Graphics.enable_hidpi)
}

// -------------------------------------------------------------------

// Info

// optional string author_name = 1 [(.buffers.gmx) = "option_author"];
inline bool Info::has_author_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Info::set_has_author_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Info::clear_has_author_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Info::clear_author_name() {
  author_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_author_name();
}
inline const ::std::string& Info::author_name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.author_name)
  return author_name_.GetNoArena();
}
inline void Info::set_author_name(const ::std::string& value) {
  set_has_author_name();
  author_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Info.author_name)
}
#if LANG_CXX11
inline void Info::set_author_name(::std::string&& value) {
  set_has_author_name();
  author_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Info.author_name)
}
#endif
inline void Info::set_author_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_author_name();
  author_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Info.author_name)
}
inline void Info::set_author_name(const char* value, size_t size) {
  set_has_author_name();
  author_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Info.author_name)
}
inline ::std::string* Info::mutable_author_name() {
  set_has_author_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Info.author_name)
  return author_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_author_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.Info.author_name)
  if (!has_author_name()) {
    return NULL;
  }
  clear_has_author_name();
  return author_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_author_name(::std::string* author_name) {
  if (author_name != NULL) {
    set_has_author_name();
  } else {
    clear_has_author_name();
  }
  author_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author_name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Info.author_name)
}

// optional string author_email = 2 [(.buffers.gmx) = "option_linux_maintainer_email"];
inline bool Info::has_author_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Info::set_has_author_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Info::clear_has_author_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Info::clear_author_email() {
  author_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_author_email();
}
inline const ::std::string& Info::author_email() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.author_email)
  return author_email_.GetNoArena();
}
inline void Info::set_author_email(const ::std::string& value) {
  set_has_author_email();
  author_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Info.author_email)
}
#if LANG_CXX11
inline void Info::set_author_email(::std::string&& value) {
  set_has_author_email();
  author_email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Info.author_email)
}
#endif
inline void Info::set_author_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_author_email();
  author_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Info.author_email)
}
inline void Info::set_author_email(const char* value, size_t size) {
  set_has_author_email();
  author_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Info.author_email)
}
inline ::std::string* Info::mutable_author_email() {
  set_has_author_email();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Info.author_email)
  return author_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_author_email() {
  // @@protoc_insertion_point(field_release:buffers.resources.Info.author_email)
  if (!has_author_email()) {
    return NULL;
  }
  clear_has_author_email();
  return author_email_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_author_email(::std::string* author_email) {
  if (author_email != NULL) {
    set_has_author_email();
  } else {
    clear_has_author_email();
  }
  author_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author_email);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Info.author_email)
}

// optional string website = 3 [(.buffers.gmx) = "option_linux_homepage"];
inline bool Info::has_website() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Info::set_has_website() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Info::clear_has_website() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Info::clear_website() {
  website_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_website();
}
inline const ::std::string& Info::website() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.website)
  return website_.GetNoArena();
}
inline void Info::set_website(const ::std::string& value) {
  set_has_website();
  website_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Info.website)
}
#if LANG_CXX11
inline void Info::set_website(::std::string&& value) {
  set_has_website();
  website_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Info.website)
}
#endif
inline void Info::set_website(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_website();
  website_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Info.website)
}
inline void Info::set_website(const char* value, size_t size) {
  set_has_website();
  website_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Info.website)
}
inline ::std::string* Info::mutable_website() {
  set_has_website();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Info.website)
  return website_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_website() {
  // @@protoc_insertion_point(field_release:buffers.resources.Info.website)
  if (!has_website()) {
    return NULL;
  }
  clear_has_website();
  return website_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_website(::std::string* website) {
  if (website != NULL) {
    set_has_website();
  } else {
    clear_has_website();
  }
  website_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), website);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Info.website)
}

// optional string version = 4 [(.buffers.gmx) = "option_version"];
inline bool Info::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Info::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Info::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Info::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Info::version() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.version)
  return version_.GetNoArena();
}
inline void Info::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Info.version)
}
#if LANG_CXX11
inline void Info::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Info.version)
}
#endif
inline void Info::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Info.version)
}
inline void Info::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Info.version)
}
inline ::std::string* Info::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Info.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_version() {
  // @@protoc_insertion_point(field_release:buffers.resources.Info.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Info.version)
}

// optional uint32 last_changed = 5 [(.buffers.gmx) = "option_lastchanged"];
inline bool Info::has_last_changed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Info::set_has_last_changed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Info::clear_has_last_changed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Info::clear_last_changed() {
  last_changed_ = 0u;
  clear_has_last_changed();
}
inline ::google::protobuf::uint32 Info::last_changed() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.last_changed)
  return last_changed_;
}
inline void Info::set_last_changed(::google::protobuf::uint32 value) {
  set_has_last_changed();
  last_changed_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Info.last_changed)
}

// optional string information = 6 [(.buffers.gmx) = "option_information"];
inline bool Info::has_information() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Info::set_has_information() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Info::clear_has_information() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Info::clear_information() {
  information_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_information();
}
inline const ::std::string& Info::information() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Info.information)
  return information_.GetNoArena();
}
inline void Info::set_information(const ::std::string& value) {
  set_has_information();
  information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Info.information)
}
#if LANG_CXX11
inline void Info::set_information(::std::string&& value) {
  set_has_information();
  information_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Info.information)
}
#endif
inline void Info::set_information(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_information();
  information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Info.information)
}
inline void Info::set_information(const char* value, size_t size) {
  set_has_information();
  information_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Info.information)
}
inline ::std::string* Info::mutable_information() {
  set_has_information();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Info.information)
  return information_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_information() {
  // @@protoc_insertion_point(field_release:buffers.resources.Info.information)
  if (!has_information()) {
    return NULL;
  }
  clear_has_information();
  return information_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_information(::std::string* information) {
  if (information != NULL) {
    set_has_information();
  } else {
    clear_has_information();
  }
  information_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), information);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Info.information)
}

// -------------------------------------------------------------------

// Installer

// optional string finished_image = 1 [(.buffers.gmx) = "option_windows_runner_finished"];
inline bool Installer::has_finished_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Installer::set_has_finished_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Installer::clear_has_finished_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Installer::clear_finished_image() {
  finished_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_finished_image();
}
inline const ::std::string& Installer::finished_image() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Installer.finished_image)
  return finished_image_.GetNoArena();
}
inline void Installer::set_finished_image(const ::std::string& value) {
  set_has_finished_image();
  finished_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Installer.finished_image)
}
#if LANG_CXX11
inline void Installer::set_finished_image(::std::string&& value) {
  set_has_finished_image();
  finished_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Installer.finished_image)
}
#endif
inline void Installer::set_finished_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_finished_image();
  finished_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Installer.finished_image)
}
inline void Installer::set_finished_image(const char* value, size_t size) {
  set_has_finished_image();
  finished_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Installer.finished_image)
}
inline ::std::string* Installer::mutable_finished_image() {
  set_has_finished_image();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Installer.finished_image)
  return finished_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Installer::release_finished_image() {
  // @@protoc_insertion_point(field_release:buffers.resources.Installer.finished_image)
  if (!has_finished_image()) {
    return NULL;
  }
  clear_has_finished_image();
  return finished_image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Installer::set_allocated_finished_image(::std::string* finished_image) {
  if (finished_image != NULL) {
    set_has_finished_image();
  } else {
    clear_has_finished_image();
  }
  finished_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), finished_image);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Installer.finished_image)
}

// optional string header_image = 2 [(.buffers.gmx) = "option_windows_runner_header"];
inline bool Installer::has_header_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Installer::set_has_header_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Installer::clear_has_header_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Installer::clear_header_image() {
  header_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_header_image();
}
inline const ::std::string& Installer::header_image() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Installer.header_image)
  return header_image_.GetNoArena();
}
inline void Installer::set_header_image(const ::std::string& value) {
  set_has_header_image();
  header_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Installer.header_image)
}
#if LANG_CXX11
inline void Installer::set_header_image(::std::string&& value) {
  set_has_header_image();
  header_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Installer.header_image)
}
#endif
inline void Installer::set_header_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_header_image();
  header_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Installer.header_image)
}
inline void Installer::set_header_image(const char* value, size_t size) {
  set_has_header_image();
  header_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Installer.header_image)
}
inline ::std::string* Installer::mutable_header_image() {
  set_has_header_image();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Installer.header_image)
  return header_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Installer::release_header_image() {
  // @@protoc_insertion_point(field_release:buffers.resources.Installer.header_image)
  if (!has_header_image()) {
    return NULL;
  }
  clear_has_header_image();
  return header_image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Installer::set_allocated_header_image(::std::string* header_image) {
  if (header_image != NULL) {
    set_has_header_image();
  } else {
    clear_has_header_image();
  }
  header_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header_image);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Installer.header_image)
}

// optional string script = 3 [(.buffers.gmx) = "option_windows_nsis_file"];
inline bool Installer::has_script() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Installer::set_has_script() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Installer::clear_has_script() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Installer::clear_script() {
  script_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_script();
}
inline const ::std::string& Installer::script() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Installer.script)
  return script_.GetNoArena();
}
inline void Installer::set_script(const ::std::string& value) {
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Installer.script)
}
#if LANG_CXX11
inline void Installer::set_script(::std::string&& value) {
  set_has_script();
  script_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Installer.script)
}
#endif
inline void Installer::set_script(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Installer.script)
}
inline void Installer::set_script(const char* value, size_t size) {
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Installer.script)
}
inline ::std::string* Installer::mutable_script() {
  set_has_script();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Installer.script)
  return script_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Installer::release_script() {
  // @@protoc_insertion_point(field_release:buffers.resources.Installer.script)
  if (!has_script()) {
    return NULL;
  }
  clear_has_script();
  return script_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Installer::set_allocated_script(::std::string* script) {
  if (script != NULL) {
    set_has_script();
  } else {
    clear_has_script();
  }
  script_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Installer.script)
}

// optional string license_agreement = 4 [(.buffers.gmx) = "option_windows_license"];
inline bool Installer::has_license_agreement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Installer::set_has_license_agreement() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Installer::clear_has_license_agreement() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Installer::clear_license_agreement() {
  license_agreement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_license_agreement();
}
inline const ::std::string& Installer::license_agreement() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Installer.license_agreement)
  return license_agreement_.GetNoArena();
}
inline void Installer::set_license_agreement(const ::std::string& value) {
  set_has_license_agreement();
  license_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Installer.license_agreement)
}
#if LANG_CXX11
inline void Installer::set_license_agreement(::std::string&& value) {
  set_has_license_agreement();
  license_agreement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Installer.license_agreement)
}
#endif
inline void Installer::set_license_agreement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_license_agreement();
  license_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Installer.license_agreement)
}
inline void Installer::set_license_agreement(const char* value, size_t size) {
  set_has_license_agreement();
  license_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Installer.license_agreement)
}
inline ::std::string* Installer::mutable_license_agreement() {
  set_has_license_agreement();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Installer.license_agreement)
  return license_agreement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Installer::release_license_agreement() {
  // @@protoc_insertion_point(field_release:buffers.resources.Installer.license_agreement)
  if (!has_license_agreement()) {
    return NULL;
  }
  clear_has_license_agreement();
  return license_agreement_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Installer::set_allocated_license_agreement(::std::string* license_agreement) {
  if (license_agreement != NULL) {
    set_has_license_agreement();
  } else {
    clear_has_license_agreement();
  }
  license_agreement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_agreement);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Installer.license_agreement)
}

// -------------------------------------------------------------------

// Deployment

// optional string app_id = 1 [(.buffers.gmx) = "option_mac_app_id"];
inline bool Deployment::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Deployment::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Deployment::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Deployment::clear_app_id() {
  app_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_id();
}
inline const ::std::string& Deployment::app_id() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.app_id)
  return app_id_.GetNoArena();
}
inline void Deployment::set_app_id(const ::std::string& value) {
  set_has_app_id();
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.app_id)
}
#if LANG_CXX11
inline void Deployment::set_app_id(::std::string&& value) {
  set_has_app_id();
  app_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Deployment.app_id)
}
#endif
inline void Deployment::set_app_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_id();
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Deployment.app_id)
}
inline void Deployment::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Deployment.app_id)
}
inline ::std::string* Deployment::mutable_app_id() {
  set_has_app_id();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Deployment.app_id)
  return app_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deployment::release_app_id() {
  // @@protoc_insertion_point(field_release:buffers.resources.Deployment.app_id)
  if (!has_app_id()) {
    return NULL;
  }
  clear_has_app_id();
  return app_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deployment::set_allocated_app_id(::std::string* app_id) {
  if (app_id != NULL) {
    set_has_app_id();
  } else {
    clear_has_app_id();
  }
  app_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_id);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Deployment.app_id)
}

// optional string app_output = 2 [(.buffers.gmx) = "option_mac_output_dir"];
inline bool Deployment::has_app_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Deployment::set_has_app_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Deployment::clear_has_app_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Deployment::clear_app_output() {
  app_output_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_output();
}
inline const ::std::string& Deployment::app_output() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.app_output)
  return app_output_.GetNoArena();
}
inline void Deployment::set_app_output(const ::std::string& value) {
  set_has_app_output();
  app_output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.app_output)
}
#if LANG_CXX11
inline void Deployment::set_app_output(::std::string&& value) {
  set_has_app_output();
  app_output_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Deployment.app_output)
}
#endif
inline void Deployment::set_app_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_output();
  app_output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Deployment.app_output)
}
inline void Deployment::set_app_output(const char* value, size_t size) {
  set_has_app_output();
  app_output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Deployment.app_output)
}
inline ::std::string* Deployment::mutable_app_output() {
  set_has_app_output();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Deployment.app_output)
  return app_output_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deployment::release_app_output() {
  // @@protoc_insertion_point(field_release:buffers.resources.Deployment.app_output)
  if (!has_app_output()) {
    return NULL;
  }
  clear_has_app_output();
  return app_output_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deployment::set_allocated_app_output(::std::string* app_output) {
  if (app_output != NULL) {
    set_has_app_output();
  } else {
    clear_has_app_output();
  }
  app_output_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_output);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Deployment.app_output)
}

// optional string team_identifier = 3 [(.buffers.gmx) = "option_mac_team_id"];
inline bool Deployment::has_team_identifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Deployment::set_has_team_identifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Deployment::clear_has_team_identifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Deployment::clear_team_identifier() {
  team_identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_team_identifier();
}
inline const ::std::string& Deployment::team_identifier() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.team_identifier)
  return team_identifier_.GetNoArena();
}
inline void Deployment::set_team_identifier(const ::std::string& value) {
  set_has_team_identifier();
  team_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.team_identifier)
}
#if LANG_CXX11
inline void Deployment::set_team_identifier(::std::string&& value) {
  set_has_team_identifier();
  team_identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Deployment.team_identifier)
}
#endif
inline void Deployment::set_team_identifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_team_identifier();
  team_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Deployment.team_identifier)
}
inline void Deployment::set_team_identifier(const char* value, size_t size) {
  set_has_team_identifier();
  team_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Deployment.team_identifier)
}
inline ::std::string* Deployment::mutable_team_identifier() {
  set_has_team_identifier();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Deployment.team_identifier)
  return team_identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deployment::release_team_identifier() {
  // @@protoc_insertion_point(field_release:buffers.resources.Deployment.team_identifier)
  if (!has_team_identifier()) {
    return NULL;
  }
  clear_has_team_identifier();
  return team_identifier_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deployment::set_allocated_team_identifier(::std::string* team_identifier) {
  if (team_identifier != NULL) {
    set_has_team_identifier();
  } else {
    clear_has_team_identifier();
  }
  team_identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_identifier);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Deployment.team_identifier)
}

// optional bool enable_appstore_build = 4 [(.buffers.gmx) = "option_mac_create_app_store"];
inline bool Deployment::has_enable_appstore_build() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Deployment::set_has_enable_appstore_build() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Deployment::clear_has_enable_appstore_build() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Deployment::clear_enable_appstore_build() {
  enable_appstore_build_ = false;
  clear_has_enable_appstore_build();
}
inline bool Deployment::enable_appstore_build() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.enable_appstore_build)
  return enable_appstore_build_;
}
inline void Deployment::set_enable_appstore_build(bool value) {
  set_has_enable_appstore_build();
  enable_appstore_build_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.enable_appstore_build)
}

// optional bool allow_incoming_connections = 5 [(.buffers.gmx) = "option_mac_appstore_incoming_allow"];
inline bool Deployment::has_allow_incoming_connections() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Deployment::set_has_allow_incoming_connections() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Deployment::clear_has_allow_incoming_connections() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Deployment::clear_allow_incoming_connections() {
  allow_incoming_connections_ = false;
  clear_has_allow_incoming_connections();
}
inline bool Deployment::allow_incoming_connections() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.allow_incoming_connections)
  return allow_incoming_connections_;
}
inline void Deployment::set_allow_incoming_connections(bool value) {
  set_has_allow_incoming_connections();
  allow_incoming_connections_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.allow_incoming_connections)
}

// optional bool allow_outgoing_connections = 6 [(.buffers.gmx) = "option_mac_appstore_outgoing_allow"];
inline bool Deployment::has_allow_outgoing_connections() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Deployment::set_has_allow_outgoing_connections() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Deployment::clear_has_allow_outgoing_connections() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Deployment::clear_allow_outgoing_connections() {
  allow_outgoing_connections_ = false;
  clear_has_allow_outgoing_connections();
}
inline bool Deployment::allow_outgoing_connections() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.allow_outgoing_connections)
  return allow_outgoing_connections_;
}
inline void Deployment::set_allow_outgoing_connections(bool value) {
  set_has_allow_outgoing_connections();
  allow_outgoing_connections_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.allow_outgoing_connections)
}

// optional string app_category = 7 [(.buffers.gmx) = "option_mac_app_category"];
inline bool Deployment::has_app_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Deployment::set_has_app_category() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Deployment::clear_has_app_category() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Deployment::clear_app_category() {
  app_category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_category();
}
inline const ::std::string& Deployment::app_category() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.app_category)
  return app_category_.GetNoArena();
}
inline void Deployment::set_app_category(const ::std::string& value) {
  set_has_app_category();
  app_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.app_category)
}
#if LANG_CXX11
inline void Deployment::set_app_category(::std::string&& value) {
  set_has_app_category();
  app_category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Deployment.app_category)
}
#endif
inline void Deployment::set_app_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_category();
  app_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Deployment.app_category)
}
inline void Deployment::set_app_category(const char* value, size_t size) {
  set_has_app_category();
  app_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Deployment.app_category)
}
inline ::std::string* Deployment::mutable_app_category() {
  set_has_app_category();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Deployment.app_category)
  return app_category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deployment::release_app_category() {
  // @@protoc_insertion_point(field_release:buffers.resources.Deployment.app_category)
  if (!has_app_category()) {
    return NULL;
  }
  clear_has_app_category();
  return app_category_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deployment::set_allocated_app_category(::std::string* app_category) {
  if (app_category != NULL) {
    set_has_app_category();
  } else {
    clear_has_app_category();
  }
  app_category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_category);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Deployment.app_category)
}

// optional string signing_identity = 8 [(.buffers.gmx) = "option_mac_signing_identity"];
inline bool Deployment::has_signing_identity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Deployment::set_has_signing_identity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Deployment::clear_has_signing_identity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Deployment::clear_signing_identity() {
  signing_identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signing_identity();
}
inline const ::std::string& Deployment::signing_identity() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Deployment.signing_identity)
  return signing_identity_.GetNoArena();
}
inline void Deployment::set_signing_identity(const ::std::string& value) {
  set_has_signing_identity();
  signing_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Deployment.signing_identity)
}
#if LANG_CXX11
inline void Deployment::set_signing_identity(::std::string&& value) {
  set_has_signing_identity();
  signing_identity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Deployment.signing_identity)
}
#endif
inline void Deployment::set_signing_identity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signing_identity();
  signing_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Deployment.signing_identity)
}
inline void Deployment::set_signing_identity(const char* value, size_t size) {
  set_has_signing_identity();
  signing_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Deployment.signing_identity)
}
inline ::std::string* Deployment::mutable_signing_identity() {
  set_has_signing_identity();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Deployment.signing_identity)
  return signing_identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Deployment::release_signing_identity() {
  // @@protoc_insertion_point(field_release:buffers.resources.Deployment.signing_identity)
  if (!has_signing_identity()) {
    return NULL;
  }
  clear_has_signing_identity();
  return signing_identity_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Deployment::set_allocated_signing_identity(::std::string* signing_identity) {
  if (signing_identity != NULL) {
    set_has_signing_identity();
  } else {
    clear_has_signing_identity();
  }
  signing_identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signing_identity);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Deployment.signing_identity)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace resources
}  // namespace buffers

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::buffers::resources::Graphics_VertexBufferMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::buffers::resources::Graphics_VertexBufferMethod>() {
  return ::buffers::resources::Graphics_VertexBufferMethod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Settings_2eproto
